<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
</head>

<body>
<h2>Learn</h2>

<p>Up: <a href=".">Language</a>, Prev: <a href="try">Try</a>, Next: <a href="examples">Examples</a>.</p>

<br></br>

<h1>A first look at my code</h1>

<h4>Getting it working</h4>

<p>
In this section we will look at how to read my language,
 to hopefully get an idea of what a program might do when we execute it.
 We will start with a simple program to test that everything is working.
</p>

<pre>
// learn1.my
myText = "Hello, world.";
.run = print( .val = myText,).run;
</pre>

<p>
Open your favourite text editor and type in the code block above.
Save the file, for example calling it "learn1.my".
If you followed the instructions from the <a href="try">Try</a> page to install <code>myi</code>, 
you should now be able to execute the saved code file as described in the "Writing and running your code" section.
You should see the following printed to the terminal screen:
</p>

<pre>
$ myi-exe.exe learn1.myi
Hello, world.
</pre>

<p>
Running our program made some text print on the screen!
Magic!
</p>

<h4>How it looks and what it means</h4>

<p>
The program we just created and ran is the result of the interaction of all the code we wrote.
We can break the code down into smaller pieces and consider the role of each piece,
and then considering the behaviour that results from combining these roles.
Let's start with the first line
<pre>
// learn1.my
</pre>
begins with two forward slash characters <code>//</code>.
This is how you write a "comment" in my language. 
Comments are usually for prose descriptions of code written for the benefit of the programmer –
the interpreter will see the <code>//</code> and ignore it and the remainder of the line.
Throughout these tutorials I will use this convention of putting a file name as a comment at the top of a block to indicate that the code block represents a standalone file. 
</p>

<p>
Next, the first non-trivial line
<pre>
myText = "Hello world.";
</pre>
does not begin with <code>//</code> so we know it is not a comment.
The two most important features of the line are the equals sign character <code>=</code>,
which tells us that this piece of code is a particular type of statement that associates names with code definitions,
and the semi-colon character <code>;</code>,
which tells us where the statement ends.
The part of the line up to the <code>;</code> –
<code>myText = "Hello world."</code> –
contains the statement,
called an "assignment", "definition" or "association".
This form is how you give names to reusable pieces of code in my language. 
We can break the assignment down further to the pieces to the left- and right of the <code>=</code>, 
called respectively the left- and right- hand sides.
The left hand side of the assignment above is the label <code>myText</code> followed by a space.
Spaces, like comments, are for the benefit of the reader and are ignored by the interpreter.
A label is associated with a code definition by an assignment, 
and can be used within code definitions as a shorthand for the defining code. 
In this case, the defining code is to the right of the equals sign (the right hand side) <code>"Hello world."</code>,
ignoring the leading space.
In my language, using double-quotes around text creates a literal value that represents the text shown within the quotes.
With this line, we are saying that uses of the name <code>myText</code> appearing in definitions really mean the text "Hello world.". 
</p>

<p>
The third line from the example above
<pre>
.run = print(.val = myText,).run;
</pre>
is, like the second line, another assignment, 
which we remember features a <code>=</code> separating a left hand side label and right hand side code definition, 
and ending with a <code>;</code>. 
There are a few new things though. 
First, the left hand side label <code>.run</code> starts with a period character <code>.</code>,
which denotes a "key" – 
a label with some added behaviour. 
We will see some examples of special key behaviour below.
For now, know that code definition assigned to the key <code>.run</code> is where the interpreter looks to begin running the program. 
</p>

<p>
The right hand side code <code>print(.val = myText,).run</code> is an example of an extremely common pattern in my language code.
The code has three main parts juxtaposed:
first a label <code>print</code>,
second a block of code inside a pair of parentheses <code>()</code>,
and third another label <code>.run</code> beginning with a <code>.</code> – a key.
If we look closer at the code inside the <code>()</code>—<code>.val = myText,</code>—we might recognise it as another assignment.
If we compare it to the assignment from the second line
<pre>
myText = "Hello, world.";
</pre>
we see that the assignment ends with a comma character <code>,</code>, 
which in my language takes the place of <code>;</code> as the terminator for assignments appearing inside <code>()</code>'s. 
Considering the assignment <code>.val = myText</code>
we see another key <code>.val</code> on the left hand side,
and a label <code>myText</code> on the right.
</p>

<p>
Let's elaborate on the common pattern shown here: 
The label <code>print</code> in this case is a built-in "command", 
with the ability to print a value to the terminal. 
In order to print a value, 
<code>print</code> needs that value to be associated with its key <code>.val</code>, 
which can be done via the pattern shown –
following the command <code>print</code> by the assignment to <code>.val</code> inside <code>()</code>'s.
In the third part of the pattern, 
we have followed the <code>print</code> with the key <code>.run</code>.
This is how we can tell the command to perform its particular action - 
printing to the terminal. 
The pattern shown demonstrates the two common uses for keys –
making code definitions available to commands, 
and invoking command actions associated with those keys.
</p>

<p>
We can think of this part of the pattern as "configuring" the command – 
we are telling <code>print</code> <em>what</em> to we want printed. 
The third part of the pattern—the key <code>.run</code>—is how we confirm that we want the print action to happen. 
</p>

<p>
In this case, the value that we want printed is associated with <code>myText</code>. 
We can look through the sequence of assignments in our program to find one that defines the label <code>myText</code>. 
In this case, we don't have to look far –
the previous line contains such an assignment giving <code>myText</code> the value of the literal text "Hello, world.". 
Thus, <code>print</code> prints the text "Hello, world." to the terminal.
</p>

<h4>Printing some other things</h4>

<p>
So, you can print text to the terminal with my language. 
Cool! But you can print other things too! 
Consider the following example code, from a file named "learn2.my".
</p>

<pre>
// learn2.my
myNumber = 2;
myMath = 3 * myNumber;
.run = print(.val = myMath,).run;
</pre>

<p>
Type out (or copy) the code above and save in a text file called "learn2.my". 
Run the code using the interpreter <code>myi-exe.exe</code> as we did earlier with "learn1.my", 
and you should see the following printed to the terminal:
<pre>
$ my-exe.exe learn2.my
6
</pre>
</p> 

<p>
As we just did with the first example program "learn1.my", 
we can study the the lines of the code of "learn2.my" to try to understand how the program arrived at this result. 
I will go a bit faster through this one, 
and if you find you are getting lost, 
it might help to go back and have a closer look at the breakdown of the first example. 
The first line of "learn2.my"
<pre>
// learn2.my
</pre>
contains a comment with the example file name. 
The second line
<pre>
myNumber = 2;
</pre>
is an assignment with left-hand side label <code>myNumber</code> and right hand side of the number <code>2</code>. 
Remember that this assignment means that we are choosing the name <code>myNumber</code> to be equivalent to the number <code>2</code> where ever we use it in definition code. 
The third line
<pre>
myMath = 3 * myNumber;
</pre>
assigns the label <code>myMath</code> to the right hand side <code>3 * myNumber</code>
where the asterisk symbol <code>*</code> describes a mathematical calculation - 
the multiplication of the values to the left and right. 
Essentially, this definition says to multiply the number <code>3</code> by the value of the code represented by <code>myNumber</code>. 
To find the definition for <code>myNumber</code> we look through the sequence of assignments we have made until we find a corresponding definition for that label - 
the assignment on the previous line defined <code>myNumber</code> as the number <code>2</code>.
</p>

<p>
The fourth line
<pre>
.run = print(.val = myMath,).run;
</pre>
is almost the same as the third line from the first example "learn1.my" earlier, 
except that inside the <code>()</code> <code>.val</code> is defined to a different label <code>myMath</code> instead of <code>myText</code>. 
We recall that <code>print</code> will print the value associated with <code>.val</code> to the terminal. 
Hence with this line we are saying we want to print whatever <code>myMath</code> evaluates to. 
We saw from running the code file "learn2.my" earlier that this was the number 6. 
We can confirm this by a process of repeatedly substituting names by their code definitions: 
beginning with <code>myMath</code>,
substituting the definition from the third line gives <code>myMath</code> → <code>3 * myNumber</code>.
Substituting the definition for <code>myNumber</code> from line 2 gives
<code>3 * myNumber</code> → <code>3 * 2</code>,
and finally performing the multiplication gives <code>3 * 2</code> → <code>6</code>. 
</p>

<h4>Names, grouped</h4>

<p>
Perhaps the core concept of the programs we have made so far has been giving names to pieces of code via assignment.
By doing this, we break down our program into smaller ideas, 
give names to those ideas,
then glue them together –
resulting in code that be easier to understand.
In my language, names defined by assignments are organised into groups. 
For example, so far we have writing our programs as a sequence of <code>;</code> separated assignments.
The corresponding assigned names from these form the "top-level" group. 
A rule of my language is that within any group, 
once a name is created its value cannot change, 
and no other value can be created with the same name. 
We can demonstrate this by modifying our previous program. 
The following program
<pre>
// learn2_bad.my
myNumber = 2;
myMath = 3 * myNumber;
myMath = 5;
.run = print(.val = myMath,);
</pre>
has an additional line added to it compared to "learn2.my" above. 
The new line
<pre>
myMath = 5;
</pre>
is an assignment of the number 5 to the label <code>myMath</code>. 
Type the code block into a text file editor, 
save the file as "learn2_bad.my", 
and give the file to the interpreter to run. 
You should see an error like the following.
<pre>
$ my-exe.exe learn2_bad.my
my-exe.EXE: MyExceptions [OverlappedSet (Priv (Pure (I_ "myMath")))]
</pre>
The duplicate assignments to <code>myMath</code> are forbidden as they would introduce ambiguity –
which value would be associated with <code>.val</code> and printed? 
Unique names mean that one can quickly find where a label has been assigned, 
allowing programs to be more easily understood.
</p>

<p>
The following line from the "learn2.my" example
<pre>
.run = print(.val = myMath,).run;
</pre>
demonstrates using <code>()</code> to construct a new group of names. 
We call the <code>()</code> and the assignments contained within collectively a "tuple". 
Each new group is considered distinct from other group, 
so name repetitions are allowed between groups – 
the name <code>.val</code> assigned in this group could also be assigned in the outer top-level group.
The names assigned by tuples behave differently to those in the outer group in an important way –
they aren't able to be used in right-hand side definitions,
and therefore aren't easily reusable.
This makes tuples only really useful as a way to pass code definitions to commands,
and hence only key assignments are permitted – 
i.e. all assigned labels must have an initial <code>.</code>.
As an aside, tuples do have another powerful use as destructuring patterns, 
but we won't cover that in this introduction.
</p>

<h4>Names, grouped again</h4>

<p>
In previous examples we have used the command <code>print</code> to print values to our terminal. 
We will soon see that in my language has the capability to define our own commands as well.
First though, let's imagine we have a two-dimensional co-ordinate that we want to print the height of. We might some write code like the following.
</p>

<pre>
// learn3.my
myCoord = (.x = 2, .y = 4);
.run = print(.val = myCoord.y,).run
</pre>

<p>
As you might have expected, I'll ask you to type the above code block into a text editor and save to a file "learn3.my". 
Run the file with the my language interpreter and you should see the following.
</p>

<pre>
$ myi-exe.exe learn3.my
4
</pre>

<!-- up to here -->
– in fact, a command is a definition of a group of names for our expected "inputs" – and outputs that looks a bit closer to how we have defined names so far. Let's look at some more code.
</p>

<pre>
// learn3.my

myPoint = {
  myIntercept = 2;
  .x = 4;
  .y = x + myIntercept;
};

myPointHeight = myPoint.y; 
</pre>

<p>
What's happening here? In the first few lines we define <code>myPoint</code> to be a compound value with some new but familiar syntax. Let's contrast the new syntax for the value definition with the syntax used to declare <code>myOperatingSystem</code> earlier, starting from the last character of the first line, where we have an open brace <code>{</code> instead of a bracket. The next line begins with an indent of 2 spaces. We recall that spaces (including line breaks) can be skipped over when reading my language code. The rest of the line has the familiar definition syntax, and we see a return to using semi-colons to end definitions, instead of the comma used in the bracket form. The third line defines a name which, like with the bracket syntax and unlike the other definitions we have made, is prefixed by a period. The fourth line has a similar form, and makes use of previously defined names <code>x</code> and <code>myIntercept</code> to define the name <code>y</code>. This is a key difference between the forms - when using this brace form syntax, names defined inside the braces form a group and can be referenced in definitions of the same group. Notably, we do not need the period prefix when using <code>x</code> to define other names within the group, it and the unprefixed <code>myIntercept</code> are treated the same. The next line ends the compound value with a closing brace <code>}</code>, instead of the closing bracket of the other form. Finally the definition of <code>myPoint</code> terminates with a semi-colon.
</p>

<p>
Skipping the blank line, the next part of the code defines <code>myPointHeight</code> using the previously defined name <code>myPoint</code>, referring to its <code>.y</code> component in a similar manner to how <code>versionIsModern</code> was defined earlier in terms of <code>myOperatingSystem.version</code>. This illustrates how the braces form used for <code>myPoint</code> actually specifies a compound value like that created by the bracket form, where components are denoted by period prefix on the value names.
</p>

<p>
Without a period prefix when defining the name <code>intercept</code>, my language does not allow access to <code>myPoint.intercept</code>. 
The components are the prefixed names, i.e. <code>.x</code> and <code>.y</code>.
</p>


<p>
If we consider the definitions of <code>myPoint</code>, we would expect that the <code>.y</code> component assigned to <code>myPointHeight</code> will evaluate to <code>6</code>.
</p>

<h4>Names, updated</h4>

<p>
A fundamental feature of my language is the ability to derive modified versions of values, demonstrated by the following code. Let's look at it first and then talk through what it does.
</p>

<pre>
myPoint2 = myPoint{ .x = 5 };

myPoint2Height = myPoint2.y;
</pre>

<p>
In the first of these lines, we create the name <code>myPoint2</code> and define the value using yet another new syntactic form: the use of a name <code>myPoint</code> defined earlier followed by a compound value with a component <code>.x</code>, declared using the braces form seen in the earlier definition for <code>myPoint</code>. This juxtaposition form is used to defined values that are modifications of other values, by adding new components and/or replacing already existing components. In this case, the update defines a <code>.x</code> component, which <code>myPoint</code> already has. We can understand the new value for <code>myPoint2</code> as being defined as a revised version of <code>myPoint</code>, with the <code>x</code> name defined to be <code>5</code> instead of <code>4</code>.
</p>

<p>
The last definition for <code>myPoint2Height</code> thus refers to the <code>.y</code> component of <code>myPoint2</code>, calculated using the updated <code>.x</code> component, and should evaluate to <code>7</code>.
</p>

<p>
Creating new extended and updated versions of values as exhibited by <code>myPoint2</code>'s definition is, like naming things, another way to reuse code to avoid repetition. 
</p>

<p>
There are actually only a couple more syntactical forms to my language, which we will look at briefly, then we can try it out with some examples. Another small piece of code demonstrates one of these forms.
</p>

<pre>
myPlane = { .z = .x - .y + 7 };

myPointDepth = myPlane( .x = 1, .y = 2 ).z;
</pre>

<p>
Looking at the first line, which defines the name <code>myPlane</code> as a compound value with an accessible named component <code>.z</code>, where <code>z</code> is defined using two period prefixed names <code>.x</code> and <code>.y</code> which have no corresponding definition in the group. Including the prefix when using a name with no group definition indicates that we expect values for the name to be provided in an updated version of the value. Note that directly accessing the <code>.z</code> component of <code>myPlane</code> will cause an error! Values like this with partially defined components act as templates from which complete values can be made using the value update syntax, as the next definition above demonstrates. 
</p>

<p>
With the next code part we have an example of using <code>myPlane</code>. This time we have used the bracket form of compound value definition juxtaposed with an existing value name to apply our updated values. This works in the same way as the braces form, with the <code>.x</code> and <code>.y</code> components of the defined value being substituted in the definition for <code>myPlane</code>. In this case we don't bother to name the updated value we have created, and immediately extract the <code>.z</code> component to assign as the definition for <code>myPointDepth</code>. If we look back at the definition for <code>myPlane</code> we can see that in the new value with the provided <code>.x</code> and <code>.y</code> components, the definition for the <code>.z</code> component has everything it needs and can be computed without causing an error.
</p>

<p>
We have now completed a basic tour of how my language reads and is written. For those of you who are not yet satisfied, now might be time to try some <a href="examples">Examples</a>.
</p>

<!-- unused from previous -->

<p>
My language there are a few ways to make groups of names. This is often a good strategy for organising code. Another example of a name group involves my language's compound values, which are values that group together other values called components, as in the following example.
</p>

<pre>
myOperatingSystem = ( .os = "Windows", .version = 10 );

versionIsModern = myOperatingSystem.version > 7
</pre>

<p>
So what's going on here? The first line is defining the name <code>myOperatingSystem</code> as we saw earlier, to a compound value. Let's break up the parts of the syntax: an open bracket <code>(</code>, an initial period <code>.</code>, a definition for <code>os</code>, a comma <code>,</code>, another period and definition for <code>version</code>, and a closing bracket <code>)</code>. The names defined between the brackets form a group, distinct from the names that we have defined so far. These names introduced in a bracket group are the names of the components of the compound value. In the following, when talking about a component name, we will include the period prefix.
</p>

<p>
In the last line, we create a name <code>versionIsModern</code> with a definition that begins with our previously defined named value <code>myOperatingSystem</code> followed by a period and <code>version</code>, which is the name of one of the components of <code>myOperatingSystem</code>. This syntax of following a compound value by a period and component name is a way in which we can refer to the component value. The rest of the definition uses the greater-than symbol <code>></code> to compare the <code>.version</code> component to <code>7</code>. 
</p>

<p>
When defining compound values with the bracket syntax it is possible to use names from the outer group in definitions for components as shown in the following code. Here, <code>myOldVersion</code> is used to define the <code>.version</code> component of <code>myUpgradedOperatingSystem</code>.
</p>

<pre>
myOldVersion = 7;

myUpgradedOperatingSystem = ( .os = "Windows", .version = myOldVersion + 1 );
</pre>
</body>

