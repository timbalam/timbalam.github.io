<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
</head>

<body>
<h2>Learn</h2>

<p>Up: <a href=".">Language</a>, Prev: <a href="try">Try</a>, Next: <a href="examples">Examples</a>.</p>

<br></br>

<h1>A first look at my code</h1>

<h4>Getting it working</h4>

<p>
In this section we will look at how to read my language, to hopefully get an idea of what a program might do when we execute it. We will start with a simple program to test that everything is working.
</p>

<pre>
// learn1.my
myText = "Hello, world.";
.run = print( .val = myText,);
</pre>

<p>
Open your favourite text editor and type in the code shown in the block above. Save the file, for example calling it 'learn1.my'. If you followed the instructions from the <a href="try">Try</a> page to install <code>myi</code>, you should now be able to execute the saved code file as described in the "Writing and running your code" section. You should see the following printed to the terminal screen:
</p>

<pre>
$ myi-exe.exe learn1.myi
Hello, world.
</pre>

<p>
Running our program made some text print on the screen! Magic!
</p>

<h4>How it looks and what it means</h4>

<p>
The program we just created and ran is the result of the interaction of all the code we wrote. We can break the code down into smaller pieces and consider the role of each piece, and then considering the behaviour that results from combining these roles. Let's start with the first line
<pre>
// learn1.my
</pre>
begins with two forward slash characters <code>//</code>. This is how you write a 'comment' in my language. Comments are usually for prose descriptions of code written for the benefit of the programmer - the interpreter will see the <code>//</code> and ignore it and the remainder of the line. Throughout these tutorials I will use this convention of putting a file name as a comment at the top of a block to indicate that the code block represents a standalone file. 
</p>

<p>
Next, the first non-trivial line
<pre>
myText = "Hello, world.";
</pre>
does not begin with <code>//</code> so we know it is not a comment. The two most important features of the line are the equals sign character <code>=</code>, which tells us that this piece of code is a particular type of statement that associates names with code definitions, and the semi-colon character <code>;</code>, which tells us where the statement ends. The part of the line up to the <code>;</code>
<pre>
myText = "Hello, world."
</pre>
contains the statement, called an 'assignment', 'definition' or 'association'. This form is how you give names to reusable pieces of code in my language. 
We can break the assignment down further to the pieces to the left- and right of the <code>=</code>, called respectively the left- and right- hand sides. The left hand side of the assignment above is the label
<pre>
myText
</pre>
followed by a space. Spaces, like comments, are for the benefit of the reader and are ignored by the interpreter. A label is associated with a code definition by an assignment, and can be used within code definitions as a shorthand for the defining code. In this case, the defining code is to the right of the equals sign (the right hand side)
<pre>"Hello, world."</pre>
ignoring the leading space. Using double-quotes around text is my language's way to indicate that this value is 'literally' the text shown within the quotes. With this line, we are saying that uses of the name <code>myText</code> appearing in definitions really mean the text 'Hello, world.'. 
</p>

<p>
The third line from the example above
<pre>
.run = print(.val = myText,);
</pre>
is, like the second line, another assignment, which we remember features a <code>=</code> separating a left hand side label and right hand side code definition, and ending with a <code>;</code>. There are a few new things though. First, the left hand side label
<pre>
.run
</pre>
starts with a period character <code>.</code>, which denotes a special type of label with additional abilities that we will come back to later. For now, know that this <code>.</code> makes the <code>.run</code> code definition available to be evaluated by the interpreter when we run the program. 
</p>

<p>
The right hand side code
<pre>
print(.val = myText,)
</pre>
consists of a label <code>print</code> followed by something new - a pair of parentheses <code>()</code> containing something that might look familiar
<pre>
.val = myText,
</pre>
which we might recognise as another assignment. If we compare it to the previous line
<pre>
myText = "Hello, world.";
</pre>
we see that the assignment ends with a comma character <code>,</code>, which in my language takes the place of <code>;</code> as the terminator for assignments appearing inside <code>()</code>'s. Considering the assignment
<pre>
.val = myText
</pre>
we see another special label <code>.val</code> on the left hand side, and a label <code>myText</code> on the right. We will again postpone discussing the special label <code>.val</code>, only saying that for this particular case the definition for <code>.val</code> is made available to the code defining <code>print</code>, and that <code>print</code> will print to the terminal whatever value is associated with <code>.val</code>.
</p>

<p>
In this case, that value will whatever definition is associated with <code>myText</code>. We can look through the sequence of assignments in our program to find one that defines the label <code>myText</code>. In this case, we don't have to look far - the previous line contains such an assignment giving <code>myText</code> the value of the literal text 'Hello, world.'. Thus, <code>print</code> prints the text 'Hello, world.' to the terminal.
</p>

<h4>Printing some other things</h4>

<p>
So, you can print text to the terminal with my language. Cool! But you can print other things too! Consider the following code, from a file named 'learn2.my'.
</p>

<pre>
// learn2.my
myNumber = 2;
myMath = 3 * myNumber;
.run = print(.val = myMath,);
</pre>

<p>
Type out (or copy) the code above in a text file called 'learn2.my'. Run the code using the interpreter <code>myi-exe.exe</code> as we did earlier with 'learn1.my', and you should see the following printed to the terminal:
<pre>
$ my-exe.exe learn2.my
6
</pre>
</p> 

<p>
As we just did with the first example program 'learn1.my', we can study the the lines of the code of 'learn2.my' to try to understand how the program arrived at this result. I will go a bit faster through this one, and if you find you are getting lost, it might help to go back and have a closer look at the first example breakdown. The first line of 'learn2.my' contains a comment. The second line is an assignment with left-hand side label <code>myNumber</code> and right hand side of the number <code>2</code>. Remember that this assignment means that we are choosing the name <code>myNumber</code> to be equivalent to the number <code>2</code> where ever we use it in definition code. The third line assigns the label <code>myMath</code> to the right hand side
<pre>
3 * myNumber
</pre>
where the asterisk symbol <code>*</code> describes a mathematical calculation - the multiplication of the values to the left and right. Essentially, this definition says to multiply the number <code>3</code> by the value of the code represented by <code>myNumber</code>. To find the definition for <code>myNumber</code> we look through the sequence of assignments we have made until we find a corresponding definition for that label - the assignment on the previous line defined <code>myNumber</code> as the number <code>2</code>.
</p>

<p>
The fourth line
<pre>
.run = print(.val = myMath,);
</pre>
is like the third line from the first example 'learn1.my':
<pre>
.run = print(.val = myText,);
</pre>
with <code>.val</code> inside the <code>()</code> defined to a different label <code>myMath</code> instead of <code>myText</code>. We recall that <code>print</code> will print the value associated with <code>.val</code> to the terminal. Hence we would expect that this line will print whatever <code>myNumber</code> evaluates to. We saw from running the code file 'learn2.my' earlier that this was '6'. We can confirm this by a process of repeatedly substituting names by their code definitions: in the manner of <code>myMath</code> → <code>3 * myNumber</code> → <code>3 * 2</code> → <code>6</code>. 
</p>

<h4>Names, grouped</h4>

<p>
Naming things (through assignments) is perhaps the core idea of my language. We name things to make code nicer, avoid having to repeatedly write complex bits of code, and to break complex ideas down into parts. My language allows things to be named, and additionally to form groups of named things. We have already seen this in the programs we have written so far - the set of labels defined by the <code>;</code> separated assignments form a group. A rule of my language is that within any group, once a name is created its value cannot change, and no other value can be created with the same name. Let's check this with a quick example. The following program
<pre>
// learn2_bad.my
myNumber = 2;
myMath = 3 * myNumber;
myMath = 5;
.run = print(.val = myMath,);
</pre>
has an additional line added to it compared to 'learn2.my' above. The new line
<pre>
myMath = 5;
</pre>
is an assignment of the number 5 to the label <code>myMath</code>. Type the code block into a text file editor, save the file as 'learn2_bad.my', and give the file to the interpreter to run. You should see an error like the following.
<pre>
$ my-exe.exe learn2_bad.my
my-exe.EXE: MyExceptions [OverlappedSet (Priv (Pure (I_ "myMath")))]
</pre>
The duplicate assignments to <code>myMath</code> are forbidden as they would introduce ambiguity - which value would be associated with <code>.val</code> and printed? Unique names mean that one can quickly find where a label has been assigned, allowing programs to be more easily understood. 
</p>

<p>
In my language there are a few ways to make groups of names. This is often a good strategy for organising code. Another example of a name group involves my language's compound values, which are values that group together other values called components, as in the following example.
</p>

<pre>
myOperatingSystem = ( .os = "Windows", .version = 10 );

versionIsModern = myOperatingSystem.version > 7
</pre>

<p>
So what's going on here? The first line is defining the name <code>myOperatingSystem</code> as we saw earlier, to a compound value. Let's break up the parts of the syntax: an open bracket <code>(</code>, an initial period <code>.</code>, a definition for <code>os</code>, a comma <code>,</code>, another period and definition for <code>version</code>, and a closing bracket <code>)</code>. The names defined between the brackets form a group, distinct from the names that we have defined so far. These names introduced in a bracket group are the names of the components of the compound value. In the following, when talking about a component name, we will include the period prefix.
</p>

<p>
In the last line, we create a name <code>versionIsModern</code> with a definition that begins with our previously defined named value <code>myOperatingSystem</code> followed by a period and <code>version</code>, which is the name of one of the components of <code>myOperatingSystem</code>. This syntax of following a compound value by a period and component name is a way in which we can refer to the component value. The rest of the definition uses the greater-than symbol <code>></code> to compare the <code>.version</code> component to <code>7</code>. 
</p>

<p>
When defining compound values with the bracket syntax it is possible to use names from the outer group in definitions for components as shown in the following code. Here, <code>myOldVersion</code> is used to define the <code>.version</code> component of <code>myUpgradedOperatingSystem</code>.
</p>

<pre>
myOldVersion = 7;

myUpgradedOperatingSystem = ( .os = "Windows", .version = myOldVersion + 1 );
</pre>

<h4>Names, grouped again</h4>

<p>
There is one more syntactical construction in my language for grouping of names that looks a bit closer to how we have defined names so far. Let's look at some more code.
</p>

<pre>
myPoint = {
  myIntercept = 2;
  .x = 4;
  .y = x + myIntercept;
};

myPointHeight = myPoint.y; 
</pre>

<p>
What's happening here? In the first few lines we define <code>myPoint</code> to be a compound value with some new but familiar syntax. Let's contrast the new syntax for the value definition with the syntax used to declare <code>myOperatingSystem</code> earlier, starting from the last character of the first line, where we have an open brace <code>{</code> instead of a bracket. The next line begins with an indent of 2 spaces. We recall that spaces (including line breaks) can be skipped over when reading my language code. The rest of the line has the familiar definition syntax, and we see a return to using semi-colons to end definitions, instead of the comma used in the bracket form. The third line defines a name which, like with the bracket syntax and unlike the other definitions we have made, is prefixed by a period. The fourth line has a similar form, and makes use of previously defined names <code>x</code> and <code>myIntercept</code> to define the name <code>y</code>. This is a key difference between the forms - when using this brace form syntax, names defined inside the braces form a group and can be referenced in definitions of the same group. Notably, we do not need the period prefix when using <code>x</code> to define other names within the group, it and the unprefixed <code>myIntercept</code> are treated the same. The next line ends the compound value with a closing brace <code>}</code>, instead of the closing bracket of the other form. Finally the definition of <code>myPoint</code> terminates with a semi-colon.
</p>

<p>
Skipping the blank line, the next part of the code defines <code>myPointHeight</code> using the previously defined name <code>myPoint</code>, referring to its <code>.y</code> component in a similar manner to how <code>versionIsModern</code> was defined earlier in terms of <code>myOperatingSystem.version</code>. This illustrates how the braces form used for <code>myPoint</code> actually specifies a compound value like that created by the bracket form, where components are denoted by period prefix on the value names.
</p>

<p>
Without a period prefix when defining the name <code>intercept</code>, my language does not allow access to <code>myPoint.intercept</code>. 
The components are the prefixed names, i.e. <code>.x</code> and <code>.y</code>.
</p>


<p>
If we consider the definitions of <code>myPoint</code>, we would expect that the <code>.y</code> component assigned to <code>myPointHeight</code> will evaluate to <code>6</code>.
</p>

<h4>Names, updated</h4>

<p>
A fundamental feature of my language is the ability to derive modified versions of values, demonstrated by the following code. Let's look at it first and then talk through what it does.
</p>

<pre>
myPoint2 = myPoint{ .x = 5 };

myPoint2Height = myPoint2.y;
</pre>

<p>
In the first of these lines, we create the name <code>myPoint2</code> and define the value using yet another new syntactic form: the use of a name <code>myPoint</code> defined earlier followed by a compound value with a component <code>.x</code>, declared using the braces form seen in the earlier definition for <code>myPoint</code>. This juxtaposition form is used to defined values that are modifications of other values, by adding new components and/or replacing already existing components. In this case, the update defines a <code>.x</code> component, which <code>myPoint</code> already has. We can understand the new value for <code>myPoint2</code> as being defined as a revised version of <code>myPoint</code>, with the <code>x</code> name defined to be <code>5</code> instead of <code>4</code>.
</p>

<p>
The last definition for <code>myPoint2Height</code> thus refers to the <code>.y</code> component of <code>myPoint2</code>, calculated using the updated <code>.x</code> component, and should evaluate to <code>7</code>.
</p>

<p>
Creating new extended and updated versions of values as exhibited by <code>myPoint2</code>'s definition is, like naming things, another way to reuse code to avoid repetition. 
</p>

<p>
There are actually only a couple more syntactical forms to my language, which we will look at briefly, then we can try it out with some examples. Another small piece of code demonstrates one of these forms.
</p>

<pre>
myPlane = { .z = .x - .y + 7 };

myPointDepth = myPlane( .x = 1, .y = 2 ).z;
</pre>

<p>
Looking at the first line, which defines the name <code>myPlane</code> as a compound value with an accessible named component <code>.z</code>, where <code>z</code> is defined using two period prefixed names <code>.x</code> and <code>.y</code> which have no corresponding definition in the group. Including the prefix when using a name with no group definition indicates that we expect values for the name to be provided in an updated version of the value. Note that directly accessing the <code>.z</code> component of <code>myPlane</code> will cause an error! Values like this with partially defined components act as templates from which complete values can be made using the value update syntax, as the next definition above demonstrates. 
</p>

<p>
With the next code part we have an example of using <code>myPlane</code>. This time we have used the bracket form of compound value definition juxtaposed with an existing value name to apply our updated values. This works in the same way as the braces form, with the <code>.x</code> and <code>.y</code> components of the defined value being substituted in the definition for <code>myPlane</code>. In this case we don't bother to name the updated value we have created, and immediately extract the <code>.z</code> component to assign as the definition for <code>myPointDepth</code>. If we look back at the definition for <code>myPlane</code> we can see that in the new value with the provided <code>.x</code> and <code>.y</code> components, the definition for the <code>.z</code> component has everything it needs and can be computed without causing an error.
</p>

<p>
We have now completed a basic tour of how my language reads and is written. For those of you who are not yet satisfied, now might be time to try some <a href="examples">Examples</a>.
</p>
</body>

