<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
</head>

<body>
<h2>Learn</h2>

<p>Up: <a href=".">Language</a>, Prev: <a href="try">Try</a>, Next: <a href="examples">Examples</a>.</p>

<br></br>

<h1>A first look at my code</h1>

<h2>How it looks and what it means</h2>

<p>
In this section we will look at how to read my language, to hopefully get an idea of what a program might do when we execute it. We will start with a simple bit of code demonstrating a few of my language's features. 
</p>

<pre>
myNumber = 1;
myText = "Hello, world.";

myMath = 3 * 4; 
mathWithVariables = myMath + myNumber;
</pre>

<!-- interleave meaning with syntax -->
<!-- quote lines of code in text -->

<p>
Let's go through this code line by line. The first line begins with <code>myNumber</code>, followed a space, then an equals sign <code>=</code>. In general spaces in a program are irrelevant (except to make code easier for us to read) and can be ignored. The equals sign defines the name to the left, to mean the value expressed by what comes to the right, which is the number <code>1</code>. The semi-colon <code>;</code> at the end of line indicates the end of the definition. Think of this as us choosing the name <code>myNumber</code> to be equivalent to the number <code>1</code> whereever it appears in the file. 
</p>

<p>
The second line has a similar structure to the first, starting with <code>myText</code>, followed by the equals sign and a corresponding definition. In this case, the equals sign is followed by double-quoted <code>"</code> <code>"</code> text, which has the value of the actual sequence of characters within the quotes. The definition is ended by a semi-colon. With this line, we are saying that uses of the name <code>myText</code> really mean the text "Hello, world.". 
</p>

<p>
The third line is empty, and like other spaces is cosmetic, so we can skip it.
</p>

<p>
In the fourth line, the name <code>myMath</code> is chosen to mean the result of the mathematical calculation appearing on the right hand of the equals sign. Here the numbers <code>3</code> and <code>4</code> are combined using the multiplication operation represented in perhaps the expected way by the asterisk symbol <code>*</code>. 
</p>

<p>
The fifth line has a similar form to the others, begining with a name <code>mathWithVariables</code> followed by an equals sign, then the chosen definition. In this case, the defining code uses names which match ones we created definitions for on earlier lines: <code>myMath</code> and <code>myNumber</code>. These names can be considered placeholders for their definitions, and when determining the value of <code>mathWithVariables</code>, the definitions of would be substituted and reduced in the manner of <code>mathWithVariables</code> → <code>myMath + myNumber</code> → <code>3 * 4 + 1</code> → <code>13</code>. Naming things makes writing code nicer as we can avoid having to repeatedly write complex bits of code, and also gives us a way to break complex ideas down into parts. 
</p>


<h4>Names, grouped</h4>

<p>
My language puts names into groups based on how they are defined. An example of this is the set of consecutive name definitions separated by semi-colons in a file such as what we have seen above form a group. The rules of my language are that within these groups, once a name is created its value cannot change, and no other value can be created with the same name. 
</p>

<p>
In my language there are a few ways to make groups of names. This is often a good strategy for organising code. Another example of a name group involves my language's compound values, which are values that group together other values called components, as in the following example.
</p>

<pre>
myOperatingSystem = ( .os = "Windows", .version = 10 );

versionIsModern = myOperatingSystem.version > 7
</pre>

<p>
So what's going on here? The first line is defining the name <code>myOperatingSystem</code> as we saw earlier, to a compound value. Let's break up the parts of the syntax: an open bracket <code>(</code>, an initial period <code>.</code>, a definition for <code>os</code>, a comma <code>,</code>, another period and definition for <code>version</code>, and a closing bracket <code>)</code>. The names defined between the brackets form a group, distinct from the names that we have defined so far. These names introduced in a bracket group are the names of the components of the compound value. In the following, when talking about a component name, we will include the period prefix.
</p>

<p>
In the last line, we create a name <code>versionIsModern</code> with a definition that begins with our previously defined named value <code>myOperatingSystem</code> followed by a period and <code>version</code>, which is the name of one of the components of <code>myOperatingSystem</code>. This syntax of following a compound value by a period and component name is a way in which we can refer to the component value. The rest of the definition uses the greater-than symbol <code>></code> to compare the <code>.version</code> component to <code>7</code>. 
</p>

<p>
When defining compound values with the bracket syntax it is possible to use names from the outer group in definitions for components as shown in the following code. Here, <code>myOldVersion</code> is used to define the <code>.version</code> component of <code>myUpgradedOperatingSystem</code>.
</p>

<pre>
myOldVersion = 7;

myUpgradedOperatingSystem = ( .os = "Windows", .version = myOldVersion + 1 );
</pre>

<h4>Names, grouped again</h4>

<p>
There is one more syntactical construction in my language for grouping of names that looks a bit closer to how we have defined names so far. Let's look at some more code.
</p>

<pre>
myPoint = {
  myIntercept = 2;
  .x = 4;
  .y = x + myIntercept;
};

myPointHeight = myPoint.y; 
</pre>

<p>
What's happening here? In the first few lines we define <code>myPoint</code> to be a compound value with some new but familiar syntax. Let's contrast the new syntax for the value definition with the syntax used to declare <code>myOperatingSystem</code> earlier, starting from the last character of the first line, where we have an open brace <code>{</code> instead of a bracket. The next line begins with an indent of 2 spaces. We recall that spaces (including line breaks) can be skipped over when reading my language code. The rest of the line has the familiar definition syntax, and we see a return to using semi-colons to end definitions, instead of the comma used in the bracket form. The third line defines a name which, like with the bracket syntax and unlike the other definitions we have made, is prefixed by a period. The fourth line has a similar form, and makes use of previously defined names <code>x</code> and <code>myIntercept</code> to define the name <code>y</code>. This is a key difference between the forms - when using this brace form syntax, names defined inside the braces form a group and can be referenced in definitions of the same group. Notably, we do not need the period prefix when using <code>x</code> to define other names within the group, it and the unprefixed <code>myIntercept</code> are treated the same. The next line ends the compound value with a closing brace <code>}</code>, instead of the closing bracket of the other form. Finally the definition of <code>myPoint</code> terminates with a semi-colon.
</p>

<p>
Skipping the blank line, the next part of the code defines <code>myPointHeight</code> using the previously defined name <code>myPoint</code>, referring to its <code>.y</code> component in a similar manner to how <code>versionIsModern</code> was defined earlier in terms of <code>myOperatingSystem.version</code>. This illustrates how the braces form used for <code>myPoint</code> actually specifies a compound value like that created by the bracket form, where components are denoted by period prefix on the value names.
</p>

<p>
Without a period prefix when defining the name <code>intercept</code>, my language does not allow access to <code>myPoint.intercept</code>. 
The components are the prefixed names, i.e. <code>.x</code> and <code>.y</code>.
</p>


<p>
If we consider the definitions of <code>myPoint</code>, we would expect that the <code>.y</code> component assigned to <code>myPointHeight</code> will evaluate to <code>6</code>.
</p>

<h4>Names, updated</h4>

<p>
A fundamental feature of my language is the ability to derive modified versions of values, demonstrated by the following code. Let's look at it first and then talk through what it does.
</p>

<pre>
myPoint2 = myPoint{ .x = 5 };

myPoint2Height = myPoint2.y;
</pre>

<p>
In the first of these lines, we create the name <code>myPoint2</code> and define the value using yet another new syntactic form: the use of a name <code>myPoint</code> defined earlier followed by a compound value with a component <code>.x</code>, declared using the braces form seen in the earlier definition for <code>myPoint</code>. This juxtaposition form is used to defined values that are modifications of other values, by adding new components and/or replacing already existing components. In this case, the update defines a <code>.x</code> component, which <code>myPoint</code> already has. We can understand the new value for <code>myPoint2</code> as being defined as a revised version of <code>myPoint</code>, with the <code>x</code> name defined to be <code>5</code> instead of <code>4</code>.
</p>

<p>
The last definition for <code>myPoint2Height</code> thus refers to the <code>.y</code> component of <code>myPoint2</code>, calculated using the updated <code>.x</code> component, and should evaluate to <code>7</code>.
</p>

<p>
Creating new extended and updated versions of values as exhibited by <code>myPoint2</code>'s definition is, like naming things, another way to reuse code to avoid repetition. 
</p>

<p>
There are actually only a couple more syntactical forms to my language, which we will look at briefly, then we can try it out with some examples. Another small piece of code demonstrates one of these forms.
</p>

<pre>
myPlane = { .z = .x - .y + 7 };

myPointDepth = myPlane( .x = 1, .y = 2 ).z;
</pre>

<p>
Looking at the first line, which defines the name <code>myPlane</code> as a compound value with an accessible named component <code>.z</code>, where <code>z</code> is defined using two period prefixed names <code>.x</code> and <code>.y</code> which have no corresponding definition in the group. Including the prefix when using a name with no group definition indicates that we expect values for the name to be provided in an updated version of the value. Note that directly accessing the <code>.z</code> component of <code>myPlane</code> will cause an error! Values like this with partially defined components act as templates from which complete values can be made using the value update syntax, as the next definition above demonstrates. 
</p>

<p>
With the next code part we have an example of using <code>myPlane</code>. This time we have used the bracket form of compound value definition juxtaposed with an existing value name to apply our updated values. This works in the same way as the braces form, with the <code>.x</code> and <code>.y</code> components of the defined value being substituted in the definition for <code>myPlane</code>. In this case we don't bother to name the updated value we have created, and immediately extract the <code>.z</code> component to assign as the definition for <code>myPointDepth</code>. If we look back at the definition for <code>myPlane</code> we can see that in the new value with the provided <code>.x</code> and <code>.y</code> components, the definition for the <code>.z</code> component has everything it needs and can be computed without causing an error.
</p>

<p>
We have now completed a basic tour of how my language reads and is written. For those of you who are not yet satisfied, now might be time to try some <a href="examples">Examples</a>.
</p>
</body>

