<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
</head>

<body>
<h2>Learn</h2>

<p>Up: <a href=".">Language</a>, Prev: <a href="try">Try</a>, Next: <a href="examples">Examples</a>.</p>

<br></br>

<h1>A first look at my code</h1>

<h4>Getting it working</h4>

<p>
In this section we will look at how to read my language, to hopefully get an idea of what a program might do when we execute it. We will start with a simple program to test that everything is working.
</p>

<pre>
// learn1.my
myText = "Hello, world.";
.run = print( .val = myText,);
</pre>

<p>
Open your favourite text editor and type in the code shown in the block above. Save the file, for example calling it 'learn1.my'. If you followed the instructions from the <a href="try">Try</a> page to install <code>myi</code>, you should now be able to execute the saved code file as described in the "Writing and running your code" section. You should see the following printed to the terminal screen:
</p>

<pre>
$ myi-exe.exe learn1.myi
Hello, world.
</pre>

<p>
Running our program made some text print on the screen! Magic!
</p>

<h4>How it looks and what it means</h4>

<p>
Let's break the example down: The first line
<pre>
// learn1.my
</pre>
begins with two forward slash characters <code>//</code>. This is how you write a 'comment' in my language - the <code>//</code> and the remainder of the line is ignored by the interpreter. Throughout this website I will use this convention of putting a file name as a comment at the top of a block to indicate that the code block represents a standalone file. 
</p>

<p>
The next line
<pre>
myText = "Hello, world.";
</pre>
begins with a 'label' <code>myText</code>, followed by a space, an equals sign character <code>=</code>, another space, and some 'double-quoted' text <code>"Hello, world."</code>, and ends with a semi-colon character <code>;</code>. The <code>;</code> is used in my language to separate a series of statements which associate names with code definitions. The part of the line preceding the <code>;</code>
<pre>
myText = "Hello, world."
</pre>
is such a statement. This form is how you give names and reuse pieces of code in my language. Often this is called an 'assignment', a 'definition', or an 'association'. We can break the statement down further. Looking at the code to the left hand side of the <code>=</code>, we have the label
<pre>
myText
</pre>
and a space. Spaces, like comments, are for the benefit of the reader and are ignored by the interpreter. A label, when associated with a code definition, can be used within code definitions as a shorthand for the defining code. In this case, the defining code is to the right of the equals sign
<pre>"Hello, world."</pre>
ignoring the leading space. The double-quotes indicate that this is 'literal text' and has the value of the actual sequence of characters within the quotes. With this line, we are saying that uses of the name <code>myText</code> really mean the text 'Hello, world.'. 
</p>

<p>
The third line from the example above
<pre>
.run = print(.val = myText,);
</pre>
is another name associating statement like the second line, with an <code>=</code> separating a left hand side label and right hand side code definition, and ending with a <code>;</code>. There are a few new things though. First, the left hand side label
<pre>
.run
</pre>
starts with a period character <code>.</code>, which denotes a special type of label which we will come back to later. For now, know that this <code>.</code> makes the <code>.run</code> definition available to the interpreter when we run the program. 
</p>

<p>
The right hand side code
<pre>
print(.val = myText,)
</pre>
consists of a label <code>print</code> followed by a new type of syntax. Looking closer we have
<pre>
(.val = myText,)
</pre>
with parentheses <code>()</code> surrounding something that might actually look familiar. It is another name associating statement, but this time ending with a comma character <code>,</code>, which takes the place of <code>;</code> inside <code>()</code>'s as a statement terminator. Looking at the statement
<pre>
.val = myText
</pre>
we see another special label <code>.val</code> on the left hand side, and our previously defined label <code>myText</code> on the right. We will again postpone discussing the special label, only saying that for this particular case the definition for <code>.val</code> is made available to the code defining <code>print</code>. All we will say of <code>print</code> for now is that it will print to the terminal whatever it has associated with the label <code>.val</code>.
</p>

<h4>Printing some other things</h4>

<p>
So, you can print text to the terminal with my language. Cool! But you can print other things too! Consider the following code, from a file named 'learn2.my'.
</p>

<pre>
// learn2.my
myNumber = 2;
myMath = 3 * myNumber;
.run = print(.val = myMath,);
</pre>

<p>
Type out (or copy) the code above in a text file called 'learn2.my'. Run the code using the interpreter <code>myi-exe.exe</code> as we did earlier with 'learn1.my', and you should see it print the value: <code>6</code>
</p> 

<p>
We can study the the lines of the code of 'learn2.my', to try to understand how the program arrived at this result. We begin from the second line as the first line only contains a comment. The second line
<pre>
myNumber = 2;
</pre>
is yet another example of our usual name defining statement, using the label <code>myNumber</code>. The right hand side of the <code>=</code> is the number <code>2</code>. Remember that this means that we are choosing the name <code>myNumber</code> to be equivalent to the number <code>2</code> where ever we use it in definition code.
</p>

<p>
The third line
<pre>
myMath = 3 * myNumber;
</pre>
has on the left hand side of the <code>=</code> the label <code>myText</code>. Taking a closer look at the right hand side (up to the terminating <code>;</code>)
<pre>
3 * myNumber
</pre>
we can the number <code>3</code>, followed by a space, an asterisk symbol <code>*</code>, another space, and the label <code>myNumber</code>. The <code>*</code> describes a mathematical calculation, the multiplication of the left hand value with the right. Here the number <code>3</code> is being multiplied by the code represented by <code>myNumber</code>. 
</p>



<p>
The fifth line has a similar form to the others, begining with a name <code>mathWithVariables</code> followed by an equals sign, then the chosen definition. In this case, the defining code uses names which match ones we created definitions for on earlier lines: <code>myMath</code> and <code>myNumber</code>. These names can be considered placeholders for their definitions, and when determining the value of <code>mathWithVariables</code>, the definitions of would be substituted and reduced in the manner of <code>mathWithVariables</code> → <code>myMath + myNumber</code> → <code>3 * 4 + 1</code> → <code>13</code>. Naming things makes writing code nicer as we can avoid having to repeatedly write complex bits of code, and also gives us a way to break complex ideas down into parts. 
</p>


<h4>Names, grouped</h4>

<p>
My language puts names into groups based on how they are defined. An example of this is the set of consecutive name definitions separated by semi-colons in a file such as what we have seen above form a group. The rules of my language are that within these groups, once a name is created its value cannot change, and no other value can be created with the same name. 
</p>

<p>
In my language there are a few ways to make groups of names. This is often a good strategy for organising code. Another example of a name group involves my language's compound values, which are values that group together other values called components, as in the following example.
</p>

<pre>
myOperatingSystem = ( .os = "Windows", .version = 10 );

versionIsModern = myOperatingSystem.version > 7
</pre>

<p>
So what's going on here? The first line is defining the name <code>myOperatingSystem</code> as we saw earlier, to a compound value. Let's break up the parts of the syntax: an open bracket <code>(</code>, an initial period <code>.</code>, a definition for <code>os</code>, a comma <code>,</code>, another period and definition for <code>version</code>, and a closing bracket <code>)</code>. The names defined between the brackets form a group, distinct from the names that we have defined so far. These names introduced in a bracket group are the names of the components of the compound value. In the following, when talking about a component name, we will include the period prefix.
</p>

<p>
In the last line, we create a name <code>versionIsModern</code> with a definition that begins with our previously defined named value <code>myOperatingSystem</code> followed by a period and <code>version</code>, which is the name of one of the components of <code>myOperatingSystem</code>. This syntax of following a compound value by a period and component name is a way in which we can refer to the component value. The rest of the definition uses the greater-than symbol <code>></code> to compare the <code>.version</code> component to <code>7</code>. 
</p>

<p>
When defining compound values with the bracket syntax it is possible to use names from the outer group in definitions for components as shown in the following code. Here, <code>myOldVersion</code> is used to define the <code>.version</code> component of <code>myUpgradedOperatingSystem</code>.
</p>

<pre>
myOldVersion = 7;

myUpgradedOperatingSystem = ( .os = "Windows", .version = myOldVersion + 1 );
</pre>

<h4>Names, grouped again</h4>

<p>
There is one more syntactical construction in my language for grouping of names that looks a bit closer to how we have defined names so far. Let's look at some more code.
</p>

<pre>
myPoint = {
  myIntercept = 2;
  .x = 4;
  .y = x + myIntercept;
};

myPointHeight = myPoint.y; 
</pre>

<p>
What's happening here? In the first few lines we define <code>myPoint</code> to be a compound value with some new but familiar syntax. Let's contrast the new syntax for the value definition with the syntax used to declare <code>myOperatingSystem</code> earlier, starting from the last character of the first line, where we have an open brace <code>{</code> instead of a bracket. The next line begins with an indent of 2 spaces. We recall that spaces (including line breaks) can be skipped over when reading my language code. The rest of the line has the familiar definition syntax, and we see a return to using semi-colons to end definitions, instead of the comma used in the bracket form. The third line defines a name which, like with the bracket syntax and unlike the other definitions we have made, is prefixed by a period. The fourth line has a similar form, and makes use of previously defined names <code>x</code> and <code>myIntercept</code> to define the name <code>y</code>. This is a key difference between the forms - when using this brace form syntax, names defined inside the braces form a group and can be referenced in definitions of the same group. Notably, we do not need the period prefix when using <code>x</code> to define other names within the group, it and the unprefixed <code>myIntercept</code> are treated the same. The next line ends the compound value with a closing brace <code>}</code>, instead of the closing bracket of the other form. Finally the definition of <code>myPoint</code> terminates with a semi-colon.
</p>

<p>
Skipping the blank line, the next part of the code defines <code>myPointHeight</code> using the previously defined name <code>myPoint</code>, referring to its <code>.y</code> component in a similar manner to how <code>versionIsModern</code> was defined earlier in terms of <code>myOperatingSystem.version</code>. This illustrates how the braces form used for <code>myPoint</code> actually specifies a compound value like that created by the bracket form, where components are denoted by period prefix on the value names.
</p>

<p>
Without a period prefix when defining the name <code>intercept</code>, my language does not allow access to <code>myPoint.intercept</code>. 
The components are the prefixed names, i.e. <code>.x</code> and <code>.y</code>.
</p>


<p>
If we consider the definitions of <code>myPoint</code>, we would expect that the <code>.y</code> component assigned to <code>myPointHeight</code> will evaluate to <code>6</code>.
</p>

<h4>Names, updated</h4>

<p>
A fundamental feature of my language is the ability to derive modified versions of values, demonstrated by the following code. Let's look at it first and then talk through what it does.
</p>

<pre>
myPoint2 = myPoint{ .x = 5 };

myPoint2Height = myPoint2.y;
</pre>

<p>
In the first of these lines, we create the name <code>myPoint2</code> and define the value using yet another new syntactic form: the use of a name <code>myPoint</code> defined earlier followed by a compound value with a component <code>.x</code>, declared using the braces form seen in the earlier definition for <code>myPoint</code>. This juxtaposition form is used to defined values that are modifications of other values, by adding new components and/or replacing already existing components. In this case, the update defines a <code>.x</code> component, which <code>myPoint</code> already has. We can understand the new value for <code>myPoint2</code> as being defined as a revised version of <code>myPoint</code>, with the <code>x</code> name defined to be <code>5</code> instead of <code>4</code>.
</p>

<p>
The last definition for <code>myPoint2Height</code> thus refers to the <code>.y</code> component of <code>myPoint2</code>, calculated using the updated <code>.x</code> component, and should evaluate to <code>7</code>.
</p>

<p>
Creating new extended and updated versions of values as exhibited by <code>myPoint2</code>'s definition is, like naming things, another way to reuse code to avoid repetition. 
</p>

<p>
There are actually only a couple more syntactical forms to my language, which we will look at briefly, then we can try it out with some examples. Another small piece of code demonstrates one of these forms.
</p>

<pre>
myPlane = { .z = .x - .y + 7 };

myPointDepth = myPlane( .x = 1, .y = 2 ).z;
</pre>

<p>
Looking at the first line, which defines the name <code>myPlane</code> as a compound value with an accessible named component <code>.z</code>, where <code>z</code> is defined using two period prefixed names <code>.x</code> and <code>.y</code> which have no corresponding definition in the group. Including the prefix when using a name with no group definition indicates that we expect values for the name to be provided in an updated version of the value. Note that directly accessing the <code>.z</code> component of <code>myPlane</code> will cause an error! Values like this with partially defined components act as templates from which complete values can be made using the value update syntax, as the next definition above demonstrates. 
</p>

<p>
With the next code part we have an example of using <code>myPlane</code>. This time we have used the bracket form of compound value definition juxtaposed with an existing value name to apply our updated values. This works in the same way as the braces form, with the <code>.x</code> and <code>.y</code> components of the defined value being substituted in the definition for <code>myPlane</code>. In this case we don't bother to name the updated value we have created, and immediately extract the <code>.z</code> component to assign as the definition for <code>myPointDepth</code>. If we look back at the definition for <code>myPlane</code> we can see that in the new value with the provided <code>.x</code> and <code>.y</code> components, the definition for the <code>.z</code> component has everything it needs and can be computed without causing an error.
</p>

<p>
We have now completed a basic tour of how my language reads and is written. For those of you who are not yet satisfied, now might be time to try some <a href="examples">Examples</a>.
</p>
</body>

