<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
</head>

<body>
<h2>Learn</h2>

<p>Up: <a href="..">Language</a>, Next: <a href="examples">Examples</a>.</p>

<br></br>

<iframe src="webi.html" style="width: 98%" height="360"></iframe>

<h1>A first look at my code</h1>

<h4>Getting it working</h4>

<p>
In this section we will look at how to read my language,
 to hopefully get an idea of what a program might do when we execute it.
 We will start with a simple program to test that everything is working.
</p>


<pre>
// learn1.my
myText = "Hello world.";
.run = print(.val = myText,).run;
</pre>

<p>
Open your favourite text editor and type in the code block above.
Save the file, for example calling it "learn1.my".
If you followed the instructions from the <a href="try">Try</a> page to install <code>myi</code>, 
you should now be able to execute the saved code file as described in the "Writing and running your code" section.
You should see the following printed to the terminal screen:
</p>

<pre>
$ myi-exe.exe learn1.myi
Hello world.
</pre>

<p>
Running our program made some text print on the screen!
Magic!
</p>

<h4>How it looks and what it means</h4>

<p>
Learning to read my language code means learning the code syntax –
how programming concepts are represented as text.
In the following I will briefly describe the syntax and meaning of the code shown in the program above.
To begin, the first line shows our first example of syntax:
a sequence of two forward slash symbols <code>//</code>.
</p>

<pre>
1 | // learn1.my
    ^^
</pre>

<p>
This syntax indicates the start of a "comment" in my language –
The <code>//</code> and everything on the rest of the line are ignored when running the code.
Comments can be used for any purpose,
and are often used for prose descriptions of code, 
written for the benefit of the programmer.
Throughout these tutorials I will use the convention seen here of putting a file name as a comment at the top of a block to indicate that the code block represents a standalone file. 
</p>

<p>
Looking at the second line
we can break apart the pieces of syntax –
from the left we see first a sequence of alphabetic characters <code>myText</code> forming a word.
<pre>
2 | myText = "Hello world.";
    ^^^^^^
</pre>
Next is a space, then an equals sign symbol <code>=</code>.
<pre>
2 | myText = "Hello world.";
           ^
</pre>
Next is another space, then a sentence in double quotes <code>"Hello world."</code>.
<pre>
2 | myText = "Hello world.";
             ^^^^^^^^^^^^^^
</pre>
Finally, we have a semi-colon symbol <code>;</code>.
<pre>
2 | myText = "Hello world.";
                           ^
</pre>
This combination of syntax demonstrates a very common form in my language, 
called an "assignment". 
With this form you can give names to reusable pieces of code in my language,
by associating a word (a "label") with a code definition.
An assigned label can be referred to within code definitions as shorthand for its definition. 
The form begins with the left-hand side of the assignment, which above is the label <code>myText</code> followed by a space.
Spaces, like comments, are for the benefit of the reader and are ignored by the interpreter, 
and the label does not include the space.
The <code>=</code> indicates the start of the code definition, 
occurring on the assignment's right-hand side.
The code definition continues until the <code>;</code> terminator.
In this case, the defining code is the double-quoted sentence <code>"Hello world."</code>
(as usual the leading space can be ignored).
In my language, using double-quotes around text creates a literal value that represents the text shown within the quotes.
With this line, we are saying that uses of the name <code>myText</code> appearing in definitions really mean the text "Hello world.". 
(Note that inside quotes, spaces are significant and not ignored!)
</p>

<p>
The third line from the example above is,
an assignment like the second line, 
but this time featuring some new syntax on the left-hand side –
we see a period character <code>.</code> before the usual label.
<pre>
3 | .run = print(.val = myText,).run;
    ^^^^
</pre>
Following that we see the same <code>=</code>, 
and a right-hand side code definition, 
finally ending with a <code>;</code>. 
The code definition also shows some new syntax:
First a label <code>print</code>.
<pre>
3 | .run = print(.val = myText,).run;
           ^^^^^
</pre>
Following that is an opening parenthesis <code>(</code>,
a block of code,
and a closing parenthesis <code>)</code>.
<pre>
3 | .run = print(.val = myText,).run;
                ^^^^^^^^^^^^^^^^
</pre>
Finally, we see another <code>.</code> with a label, this time <code>run</code>.
<pre>
3 | .run = print(.val = myText,).run;
                                ^^^^
</pre>
Coming back to the code inside the parentheses, we might recognise it as another assignment!
<pre>
3 | .run = print(.val = myText,).run;
                 ^^^^^^^^^^^^^^
</pre>
We call this form with a <code>()</code> and an inner sequence of assignments collectively a "tuple". 
If we compare to the other assignments we have seen, for example from the second line
<pre>
2 | myText = "Hello world.";
</pre>
we see that the assignment inside the tuple ends with a comma character <code>,</code>. 
In my language <code>,</code> takes the place of <code>;</code> as the terminator for tuple assignments.
For the left-hand side of the tuple assignment we see another <code>.</code> before a label <code>val</code>.
<pre>
3 | .run = print(.val = myText,).run;
                 ^^^^
</pre>
Finally, on the right-hand side we see a label <code>myText</code>.
<pre>
3 | .run = print(.val = myText,).run;
                        ^^^^^^
</pre>
</p>

<p>
This example shows two uses of <code>.</code> before a label on the left-hand side of an assignment –
when assigning <code>run</code>, and <code>val</code>.
In my language this indicates that the label is "public".
For now, we can just treat these labels the same as if the <code>.</code> wasn't there.
The left-hand side assignment to <code>run</code> has a special meaning in my language code,
as the code definition assigned to a public label <code>run</code> is communicated to the interpreter to be executed when the program is run.
</p>

<p>
The syntax shown in the code definition for <code>run</code>
<pre>
3 | .run = print(.val = myText,).run
           ^^^^^^^^^^^^^^^^^^^^^^^^^
</pre>
is an example of another common pattern in my language code.
The label <code>print</code> in this case is a built-in "command", 
with the ability to print a value to the terminal. 
In the pattern, the command is followed by a tuple of assignments –
which is a way in my language to "communicate" values to the command.
In this case, the <code>print</code> command finds the value to print from the value communicated to it with the public label <code>val</code>, 
which we set via the (public) assignment to <code>val</code> in the tuple.
Finally, the pattern ends with a <code>.</code> followed by a label.
This is how we tell the command to perform an action.
When we tell the command <code>print</code> to <code>run</code>, 
it knows to print to the terminal.
</p>

<p>
The pattern shown by the code definition demonstrates two common uses for public labels.
The first is when communicating values to commands –
only values with public labels are communicated,
meaning <code>val</code> needs to be public.
The second is invoking command actions –
the syntax for giving the <code>run</code> instruction to the command mirrors that for denoting public labels. 
We will see the reason for this later. 
</p>

<p>
We can think of the pattern as a two-stage process.
First we use a tuple of values to "configure" the command – 
we tell <code>print</code> <em>what</em> to print.
Second we pass the label <code>run</code> to actually invoke the print action. 
</p>

<p>
As we mentioned earlier, in this case the value that we want printed is that assigned to <code>myText</code>. 
We can look through the sequence of assignments in our program to find one that defines the label <code>myText</code>. 
We don't have to look far –
the previous line contains such an assignment giving <code>myText</code> the value of the literal text "Hello, world.". 
<pre>
2 | myText = "Hello world.";
</pre>
Thus, the <code>run</code> action of <code>print</code> prints the text "Hello, world." to the terminal.
</p>

<h4>Printing some other things</h4>

<p>
So, you can print text to the terminal with my language. 
Cool! But you can print other things too! 
Consider the following example code, from a file named "learn2.my".
</p>

<pre>
// learn2.my
myNumber = 2;
myMath = 3 * myNumber;
.run = print(.val = myMath,).run;
</pre>

<p>
Type out (or copy) the code above and save in a text file called "learn2.my". 
Run the code using the interpreter <code>myi-exe.exe</code> as we did earlier with "learn1.my", 
and you should see the following printed to the terminal:
<pre>
$ my-exe.exe learn2.my
6
</pre>
</p> 

<p>
As we just did with the first example program "learn1.my", 
we can study the the lines of the code of "learn2.my" to try to understand how the program arrived at this result. 
I will go a bit faster through this one, 
and if you find you are getting lost, 
it might help to go back and have a closer look at the breakdown of the first example. 
The first line of "learn2.my" contains a comment with the example file name. 
The second line is an assignment with left-hand side label <code>myNumber</code>
<pre>
2 | myNumber = 2;
    ^^^^^^^^
</pre>
and right hand side of the number 2. 
<pre>
2 | myNumber = 2;
               ^
</pre>
Remember that this assignment means that we are choosing the name <code>myNumber</code> to be equivalent to the number 2 where ever we use it in definition code. 
The third line assigns the label <code>myMath</code> 
<pre>
3 | myMath = 3 * myNumber;
    ^^^^^^
</pre>
to the right hand side
<pre>
3 | myMath = 3 * myNumber;
             ^^^^^^^^^^^^
</pre>
where the asterisk symbol <code>*</code> describes a mathematical equation - 
the multiplication of the values to the left and right. 
Essentially, this definition says to multiply the number 3 by the value of the code represented by <code>myNumber</code>. 
To find the definition for <code>myNumber</code> we look through the sequence of assignments we have made until we find a corresponding definition for that label - 
the assignment on the previous line defined <code>myNumber</code> as the number 2.
<pre>
2 | myNumber = 2;
</pre>
</p>

<p>
The fourth line is almost the same as the third line from the first example "learn1.my" earlier, 
except that the tuple assignment <code>.val</code> is defined with a label <code>myMath</code> (the previous example defined <code>val</code> as <code>myText</code>). 
<pre>
4 | .run = print(.val = myMath,).run;
                        ^^^^^^
</pre>
We recall that <code>print</code> will print the value associated with <code>.val</code> to the terminal. 
Hence with this line we are saying we want to print whatever <code>myMath</code> evaluates to. 
We saw from running the code file "learn2.my" earlier that this was the number 6. 
We can confirm this by a process of repeatedly substituting names by their code definitions beginning with <code>myMath</code>:
</p>
<table>
<tr>
  <td><code>myMath</code></td>
</tr>
<tr>
  <td><code>3 * myNumber</code></td>
  <td>Substituting <code>myMath</code> (line 3)</td>
</tr>
<tr>
  <td><code>3 * 2</code></td>
  <td>Substituting <code>myNumber</code> (line 2)</td>
</tr>
<tr>
  <td><code>6</code></td><td>Performing <code>*</code></td>
</tr>
</table>

<h4>Names, grouped</h4>

<p>
Perhaps the core concept of the programs we have made so far has been giving names to pieces of code via assignment.
By doing this, we break down our program into smaller ideas, 
give names to those ideas,
then glue them together –
resulting in code that be easier to understand.
In my language, names defined by assignments are organised into groups. 
For example, so far we have writing our programs as a sequence of <code>;</code> separated assignments.
The corresponding assigned names from these form the "top-level" group. 
A rule of my language is that within any group, 
once a name is created its value cannot change, 
and no other value can be created with the same name. 
We can demonstrate this by modifying our previous program. 
The following program
<pre>
// learn2_bad.my
myNumber = 2;
myMath = 3 * myNumber;
myMath = 5;
.run = print(.val = myMath,);
</pre>
has an additional line added to it compared to "learn2.my" above. 
The new line
<pre>
4 | myMath = 5;
</pre>
is an assignment of the number 5 to the label <code>myMath</code>. 
Type the code block into a text file editor, 
save the file as "learn2_bad.my", 
and give the file to the interpreter to run. 
You should see an error like the following.
<pre>
$ my-exe.exe learn2_bad.my
my-exe.EXE: MyExceptions [OverlappedSet (Priv (Pure (I_ "myMath")))]
</pre>
The duplicate assignments to <code>myMath</code> are forbidden as they would introduce ambiguity –
which value would be associated with <code>val</code> and communicated to <code>print</code>? 
Unique names mean that one can quickly find where a label has been assigned, 
allowing programs to be more easily understood.
</p>

<p>
We have seen the tuple construction a few times so far,
first in line 3 of the "learn1.my".
Tuples construct new group of names.
Each new group is considered distinct from other group, 
so name repetitions are allowed between groups – 
the name <code>val</code> assigned in this group could also be assigned in the top-level group.
The names assigned by tuples behave differently to those in the top-level group in an important way –
they aren't able to be used in right-hand side definitions,
and therefore aren't easily reusable.
This makes tuples only really useful as a way to pass code definitions to commands,
and hence only public label assignments are permitted – 
i.e. all assigned labels must be prefixed with <code>.</code>.
As an aside, tuples do have another powerful use as destructuring patterns, 
but we won't cover that in this introduction.
</p>

<h4>Names, grouped, demonstrated</h4>

<p>
In previous examples we have used the command <code>print</code> to print values to our terminal. 
We will soon see that in my language has the capability to define our own commands as well.
First though, let's imagine we have a two-dimensional co-ordinate that we want to print the y-axis component of. We might some write code like the following.
</p>

<pre>
// learn3.my
myPoint = (.x = 2, .y = 4);
.run = print(.val = myPoint.y,).run
</pre>

<p>
As you might have expected, I'll ask you to type the above code block into a text editor and save to a file "learn3.my". 
Run the file with the my language interpreter and you should see the following.
</p>

<pre>
$ myi-exe.exe learn3.my
4
</pre>

<p>
There are perhaps some interesting new things in this example. Let's skip the (trivial) first line and look closer at line 2.
As you might have guessed, this line is an assignment to the label <code>myPoint</code>.
The assigned value
<pre>
2 | myPoint = (.x = 2, .y = 4);
              ^^^^^^^^^^^^^^^^
</pre>
is a tuple, 
which we might remember is syntactically a sequence of <code>,</code> separated assignments inside <code>()</code>s. 
In this case the tuple defines numeric values for two public names <code>x</code> and <code>y</code> – 
the x- and y- "co-ordinates" of a point.
We can see on the next line
<pre>
3 | .run = print(.val = myPoint.y,).run
</pre>
how to talk about the values of public names like these. 
The line you might notice is the usual invoking of the <code>print</code> command like we have seen in previous examples.
The value assigned to the tuple name <code>val</code> as the value to be printed should be read as the label <code>myPoint</code>
<pre>
3 | .run = print(.val = myPoint.y,).run
                        ^^^^^^^
</pre>
followed by the public prefix <code>.</code> and label <code>.y</code>.
<pre>
3 | .run = print(.val = myPoint.y,).run
                               ^^
</pre>
This is the same pattern that we use to run our <code>print</code> command.
We recall that following the command by the public name <code>run</code> would invoke the print action.
To work out what is to be printed, the program will look for the definition <code>myPoint</code>,
and then invoke the corresponding action associated with the public name <code>y</code>.
Looking through our program, we find the relevant definition on line 2.
<pre>
2 | myPoint = (.x = 2, .y = 4);
</pre>
For a tuple, the action invoked by a public name is to simply to get the value assigned to that name in the tuple.
(It is an error to invoke a name that is not assigned in the tuple.)
Invoking <code>y</code> on the tuple defined for <code>myPoint</code> will thus return 4,
which is the value printed.
</p>

<p>
A slightly more useful thing then printing the y-component value of a single point,
would be to print y-component values that are related to the x-components –
i.e. a line.
Let's try to generalise our previous example, and modify the definition of <code>myPoint</code> so that the  <code>y</code> coordinate is related to the <code>x</code> by the line "y = x + 2".
</p>

<pre>
// learn4_bad.my
myPoint = (.x = 2, .y = x + 2);
.run = print(.val = myPoint.y,).run
</pre>

<p>
However, this doesn't quite work! After saving the above block of code to a file "learn4_bad.my" and running you should see the following error.
</p>

<pre>
$ myi-exe.exe learn4_bad.my
my-exe.EXE: MyExceptions [ScopeError (Priv (Pure (I_ "x")))]
</pre>

<p>
The error tells us that we have used the label <code>x</code> without defining it. 
Recall that earlier I said that tuple assignments aren't the same as top-level ones,
and assigned names aren't used for determining values to substitute for label usages.
This is the cause of the error –
there is no value assigned to <code>x</code> that can be substituted into the tuple definition for <code>y</code>.
</p>

<p>
Don't worry if this all seems a bit confusing! 
We have available a simple fix: 
an alternative construction called a "block",
demonstrated in the following fixed example.
</p>

<pre>
// learn4.my
myPoint = {.x = 2; .y = x + 2};
.run = print(.val = myPoint.y,).run
</pre>

<p>
Follow the usual process – type, save to a file "learn4.my" and run. You should see the following.
</p>

<pre>
$ myi-exe.exe learn4.my
4
</pre>

<p>
Woah!
What did we do?
Focusing on the changed line 2, we have replaced the tuple construction syntax with a new syntax for constructing a "block". 
Instead of <code>()</code> we employ opening and closing brace characters <code>{}</code>.
<pre>
2 | myPoint = {.x = 2; .y = x + 2};
              ^                  ^
</pre>
Instead of <code>,</code> for terminating assignments, we return to the usual <code>;</code>.
<pre>
2 | myPoint = {.x = 2; .y = x + 2};
                     ^
</pre>
The return of <code>;</code> as assignment terminator suggests a return to the top-level behaviour of assignments,
which is the case.
</p>

<p>
Before we look at the block construction in more depth, 
we should note that we didn't need to change the reference to <code>myPoint</code> on line 3!
<pre>
3 | .run = print(.val = myPoint.y,).run
                        ^^^^^^^^^
</pre>
I.e. we can invoke the name <code>y</code> on the new block definition of <code>myPoint</code> in the same way as with the tuple definition.
</p>

<p>
Let's come back to the block construction shown.
Like a tuple, a block introduces a new name group. 
Contrary to a tuple, names defined within the block <em>are</em> available to be used as placeholders in definitions made the block.
In this case, to calculate the value for <code>y</code> we need to know the value for <code>x</code>.
<pre>
2 | myPoint = {.x = 2; .y = x + 2};
                            ^
</pre>
We search within the assignments of the block and find the definition.
<pre>
2 | myPoint = {.x = 2; .y = x + 2};
               ^^^^^^
</pre>
A subtle point is that we used the label <code>x</code> plain in the definition of <code>y</code> to refer to the public definition without needing to include the prefix <code>.</code>.
This follows from earlier when I said that we can generally get away with thinking of public name definitions as though they were defined in the normal way (without the <code>.</code>). 
</p>


<!-- up to here -->

<p>
Names defined in a block take precedence over ("shadow") any identical names defined in code outside the block.
So when determining the value for a label used in a definition,
the names defined in the current block are searched,
then the names of the enclosing block,
and so forth up to the top-level name group.
Finally, builtin names such as <code>print</code> are searched.
<p>


– in fact, a command is a definition of a group of names for our expected "inputs" – and outputs that looks a bit closer to how we have defined names so far. Let's look at some more code.
</p>

<pre>
// learn3.my

myPoint = {
  myIntercept = 2;
  .x = 4;
  .y = x + myIntercept;
};

myPointHeight = myPoint.y; 
</pre>

<p>
What's happening here? In the first few lines we define <code>myPoint</code> to be a compound value with some new but familiar syntax. Let's contrast the new syntax for the value definition with the syntax used to declare <code>myOperatingSystem</code> earlier, starting from the last character of the first line, where we have an open brace <code>{</code> instead of a bracket. The next line begins with an indent of 2 spaces. We recall that spaces (including line breaks) can be skipped over when reading my language code. The rest of the line has the familiar definition syntax, and we see a return to using semi-colons to end definitions, instead of the comma used in the bracket form. The third line defines a name which, like with the bracket syntax and unlike the other definitions we have made, is prefixed by a period. The fourth line has a similar form, and makes use of previously defined names <code>x</code> and <code>myIntercept</code> to define the name <code>y</code>. This is a key difference between the forms - when using this brace form syntax, names defined inside the braces form a group and can be referenced in definitions of the same group. Notably, we do not need the period prefix when using <code>x</code> to define other names within the group, it and the unprefixed <code>myIntercept</code> are treated the same. The next line ends the compound value with a closing brace <code>}</code>, instead of the closing bracket of the other form. Finally the definition of <code>myPoint</code> terminates with a semi-colon.
</p>

<p>
Skipping the blank line, the next part of the code defines <code>myPointHeight</code> using the previously defined name <code>myPoint</code>, referring to its <code>.y</code> component in a similar manner to how <code>versionIsModern</code> was defined earlier in terms of <code>myOperatingSystem.version</code>. This illustrates how the braces form used for <code>myPoint</code> actually specifies a compound value like that created by the bracket form, where components are denoted by period prefix on the value names.
</p>

<p>
Without a period prefix when defining the name <code>intercept</code>, my language does not allow access to <code>myPoint.intercept</code>. 
The components are the prefixed names, i.e. <code>.x</code> and <code>.y</code>.
</p>


<p>
If we consider the definitions of <code>myPoint</code>, we would expect that the <code>.y</code> component assigned to <code>myPointHeight</code> will evaluate to <code>6</code>.
</p>

<h4>Names, updated</h4>

<p>
A fundamental feature of my language is the ability to derive modified versions of values, demonstrated by the following code. Let's look at it first and then talk through what it does.
</p>

<pre>
myPoint2 = myPoint{ .x = 5 };

myPoint2Height = myPoint2.y;
</pre>

<p>
In the first of these lines, we create the name <code>myPoint2</code> and define the value using yet another new syntactic form: the use of a name <code>myPoint</code> defined earlier followed by a compound value with a component <code>.x</code>, declared using the braces form seen in the earlier definition for <code>myPoint</code>. This juxtaposition form is used to defined values that are modifications of other values, by adding new components and/or replacing already existing components. In this case, the update defines a <code>.x</code> component, which <code>myPoint</code> already has. We can understand the new value for <code>myPoint2</code> as being defined as a revised version of <code>myPoint</code>, with the <code>x</code> name defined to be <code>5</code> instead of <code>4</code>.
</p>

<p>
The last definition for <code>myPoint2Height</code> thus refers to the <code>.y</code> component of <code>myPoint2</code>, calculated using the updated <code>.x</code> component, and should evaluate to <code>7</code>.
</p>

<p>
Creating new extended and updated versions of values as exhibited by <code>myPoint2</code>'s definition is, like naming things, another way to reuse code to avoid repetition. 
</p>

<p>
There are actually only a couple more syntactical forms to my language, which we will look at briefly, then we can try it out with some examples. Another small piece of code demonstrates one of these forms.
</p>

<pre>
myPlane = { .z = .x - .y + 7 };

myPointDepth = myPlane( .x = 1, .y = 2 ).z;
</pre>

<p>
Looking at the first line, which defines the name <code>myPlane</code> as a compound value with an accessible named component <code>.z</code>, where <code>z</code> is defined using two period prefixed names <code>.x</code> and <code>.y</code> which have no corresponding definition in the group. Including the prefix when using a name with no group definition indicates that we expect values for the name to be provided in an updated version of the value. Note that directly accessing the <code>.z</code> component of <code>myPlane</code> will cause an error! Values like this with partially defined components act as templates from which complete values can be made using the value update syntax, as the next definition above demonstrates. 
</p>

<p>
With the next code part we have an example of using <code>myPlane</code>. This time we have used the bracket form of compound value definition juxtaposed with an existing value name to apply our updated values. This works in the same way as the braces form, with the <code>.x</code> and <code>.y</code> components of the defined value being substituted in the definition for <code>myPlane</code>. In this case we don't bother to name the updated value we have created, and immediately extract the <code>.z</code> component to assign as the definition for <code>myPointDepth</code>. If we look back at the definition for <code>myPlane</code> we can see that in the new value with the provided <code>.x</code> and <code>.y</code> components, the definition for the <code>.z</code> component has everything it needs and can be computed without causing an error.
</p>

<p>
We have now completed a basic tour of how my language reads and is written. For those of you who are not yet satisfied, now might be time to try some <a href="examples">Examples</a>.
</p>

<!-- unused from previous -->

<p>
My language there are a few ways to make groups of names. This is often a good strategy for organising code. Another example of a name group involves my language's compound values, which are values that group together other values called components, as in the following example.
</p>

<pre>
myOperatingSystem = ( .os = "Windows", .version = 10 );

versionIsModern = myOperatingSystem.version > 7
</pre>

<p>
So what's going on here? The first line is defining the name <code>myOperatingSystem</code> as we saw earlier, to a compound value. Let's break up the parts of the syntax: an open bracket <code>(</code>, an initial period <code>.</code>, a definition for <code>os</code>, a comma <code>,</code>, another period and definition for <code>version</code>, and a closing bracket <code>)</code>. The names defined between the brackets form a group, distinct from the names that we have defined so far. These names introduced in a bracket group are the names of the components of the compound value. In the following, when talking about a component name, we will include the period prefix.
</p>

<p>
In the last line, we create a name <code>versionIsModern</code> with a definition that begins with our previously defined named value <code>myOperatingSystem</code> followed by a period and <code>version</code>, which is the name of one of the components of <code>myOperatingSystem</code>. This syntax of following a compound value by a period and component name is a way in which we can refer to the component value. The rest of the definition uses the greater-than symbol <code>></code> to compare the <code>.version</code> component to <code>7</code>. 
</p>

<p>
When defining compound values with the bracket syntax it is possible to use names from the outer group in definitions for components as shown in the following code. Here, <code>myOldVersion</code> is used to define the <code>.version</code> component of <code>myUpgradedOperatingSystem</code>.
</p>

<pre>
myOldVersion = 7;

myUpgradedOperatingSystem = ( .os = "Windows", .version = myOldVersion + 1 );
</pre>
</body>

