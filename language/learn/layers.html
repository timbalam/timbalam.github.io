<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
</head>

<body>
<h2>Layers</h2>

<p>
Up: <a href=".">Learn</a>,
Prev: <a href="names">Names</a>,
Next: <a href="shadows">Shadows</a>.
</p>

<br></br>

<h1>Names, layered</h1>

<p>
In the <a href="names">previous tutorial</a> we created a value representing a 2-D point.
A useful generalisation of this would be to have the y-component relate to the x-component –
i.e. a line.
Let's try this and see what happens.
First, below is our Goat pen.
</p>

<textarea class="codebox" style="min-height: 100px; width: 95%"></textarea>

<p>
Let's try an obvious, yet unsuccessful,
way to generalise our previous example,
and modify the definition of <code>myPoint</code> so that the y-coordinate relates to the x- by the line <strong>y = x + 2</strong>.
The new program is shown below.
</p>

<pre>
myPoint = (.x : 2, .y : x + 2);
.inspect = myPoint.y;
</pre>

<p>
We will see this doesn't quite work.
Type and run the above block of code into the Goat Pen and you should see the following error.
</p>

<pre>
error: definition missing: "x"
</pre>

<p>
The error tells us that we have used the label <code>x</code> without defining it.
This demonstrates an import distinction between tuple associations and the usual assignments we write in our program –
assignments introduce an equivalence between the name and definition,
associations only define an accessible component.
This is the cause of the error –
the label <code>x</code> doesn't have an associated definition that can be substituted into the tuple definition for <code>y</code>.
</p>

<p>
Don't worry if this all seems a bit confusing! 
We have available a simple fix: 
an alternative construction to a tuple called a "block",
demonstrated in the following fixed example.
</p>

<pre>
myPoint = {.x = 2; .y = x + 2};
.inspect = myPoint.y;
</pre>

<p>
Let's go ahead and type this into the Goat pen and run it.
You should see the following.
</p>

<pre>
4.0
</pre>

<h4>Creating blocks</h4>

<p>
Cool!
What did we do?
We made changed to line 1,
replacing the tuple creation syntax with a new syntax for constructing a "block".
The diagram below shows the relationship between tuple and block syntax.
</p>

<pre>
<table>
<tr>
  <th></th>
  <th>Tuple</th>
  <th>Block</th>
</tr>
<tr>
  <td>Begins/ends with</td>
  <td><code>()</code></td>
  <td><code>{}</code></td>
</tr>
<tr>
  <td>Association/assignment</td>
  <td><code>:</code></td>
  <td><code>=</code></td>
</tr>
<tr>
  <td>Definition terminator</td>
  <td><code>,</code></td>
  <td><code>;</code></td>
</tr>
</table>
</pre>

<p>
One thing to note with block creation syntax is that we are again using the familiar <code>=</code> for assignment and <code>;</code> for definition termination.
This correspondence with how we have been writing our programs so far is not accidental.
One way to think of blocks is as defining their own sub-programs.
At the end of the <a href="maths">Math</a> tutorial,
we introduced a way of looking at Goat programs as a set of names.
With blocks,
we don't need to settle for a single set of names for our entire program.
They are a way to introduce a new "layer" of names,
allowed to overlap with outer layers.
(Names within a layer must still be unique, though).
</p>

<h4>How it looks and what it means</h4>

<p>
Let's come back to the program we wrote,
and highlight some features of how blocks work.
<pre>
1 | myPoint = {.x = 2; .y = x + 2};
               ^^^^^^
               1            ^
                            2
2 | .inspect = myPoint.y;
              ^^^^^^^^^
              3
</pre>
<ol>
<li>
Unlike tuples, blocks feature regular assignments,
meaning names are given an equivalence with their definitions whenever they appear,
<em>within the block</em>.
</li>
<li>
We can use the name <code>x</code> in the definition of the "y" component,
without needing to include the prefix <code>.</code> used in the definition.
(The name is the thing defined,
and the <code>.</code> prefix gives the name the following additional behaviour.)
</li>
<li>
Note that we didn't need to change our definition of <code>inspect</code>!
We can access the names defined with the <code>.</code> prefix within blocks the same way we can with tuples.
For this reason, we refer to such definitions of blocks also as components.
As we have seen, the evaluated value is 4.0.
</li>
</ol>
</p>

<p>
Aside: The special <code>inspect</code> assignment we may recognise as having the <code>.</code> prefix,
making it a program-level component.
We won't get to cover exactly what this means in these tutorials, though.
</p>

<h4>Going local</h4>

<p>
In the exercise above we make a block with two components.
Unlike tuples,
but like the main definitions of our programs,
with blocks we also have the option of defining a "local" name,
by not including the <code>.</code> prefix.
Local names can be used inside the block to represent their definition,
but can't be accessed directly by code outside the block.
</p>

<p>
To observe the difference in behaviour between local and public names,
try removing the <code>.</code> prefix of the "x" component in the definition of <code>myPoint</code>.
You should find the result doesn't change.
Now try instead removing the <code>.</code> prefix of the "y" component.
You should now see an error like the following:
<pre>
error: component missing: "y"
</pre>
</p>

<script src="../script/setup-goat-web.js"></script>
<script src="../script/goat-web.js"></script>
</body>
</html>
