<h2>I have made a programming language</h2>

<a href="./index.html">Home</a>

<a href="#try-it-out">Try it out</a>

<a href="./examples/index.html">Examples</a>

<h4>I have made a programming language</h4>

<p>
I have made a programming language. I haven't decided what to call it yet. The working name for the language is "my". I have predicted that you are curious and would like to ask the following questions.  
</p>

<h4>A what? What's a programming language?</h4>

<p>
A programming language lets us describe what we would like the computer to do as text. Text written in the programming language can be read and executed by a computer program that understands the rules of the language. 
</p>

<h4>Aren't there already other programming languages? How is my language different?</h4>

<p>
My language is different from other programming languages in that it seeks to keep the number of syntactic concepts low, centering on a simple yet powerful primitive structure. This directs toward some goals of my languauge - that it should be reasonably obvious what code is going to do, and that there should also be a reasonably obvious way to get something done. Hopefully this will be illustrated as we look at some examples.
</p>

<h4>How do I use my language?</h4>

<p>
We use a text editor to write our program code, and then give the text file to the <code>myi</code> program to execute. <code>myi</code> is short for "My interpreter" because it interprets the code you wrote based on the rules of my language. <code>myi</code> is run from the command line or terminal of your computer. To install <code>myi</code> see <a href="#try-it-out">here</a>.
</p>


<h4>What does my language look like?</h4>

<p>
Here is a simple bit of code demonstrating a few of my language's features. 
</p>

<pre>
myNumber = 1;
myText = "Hello, world.";

myMath = 3 * 4; 
mathWithVariables = myMath + myNumber;
</pre>

<p>
Let's go through this code line by line. The first line begins with <code>myNumber</code>, followed a space, then an equals sign <code>=</code>. In general spaces in a program are irrelevant (except to make code easier for us to read) and can be ignored. The equals sign we say defines the meaning of the name to the left, to be the value expressed by what comes to the right, which is the number <code>1</code>. The semi-colon <code>;</code> at the end of line indicates the end of the definition. Effectively, we are choosing the name <code>myNumber</code> to be equivalent to the number <code>1</code> whereever it appears in the file. 
</p>

<p>
The second line has a similar structure to the first, using the equals sign to define the name <code>myText</code> as the corresponding right hand value. In this case, the equals sign is followed by text "quoted" using double-quotes <code>""</code>, which is how we indicate the literal string of characters "Hello, world.". The definition is ended by a semi-colon. With this line, we are saying that uses of the name <code>myText</code> really mean the text "Hello, world.". 
</p>

<p>
The third line is empty, and like other spaces is cosmetic, so we can skip it.
</p>

<p>
In the fourth line, the name <code>myMath</code> is chosen to mean the result of the mathematical calculation appearing on the right hand of the equals sign. Here the numbers <code>3</code> and <code>4</code> are combined using the multiplication operation represented in perhaps the expected way by the asterisk symbol <code>*</code>. 
</p>

<p>
The fifth line has a similar form to the others, begining with a name <code>mathWithVariables</code> followed by an equals sign, then the chosen definition. In this case, the defining code uses names which match ones we created definitions for on earlier lines: <code>myMath</code> and <code>myNumber</code>. The implication is that the names are placeholders for their definitions. Naming things makes writing code nicer as we can avoid having to repeatedly write complex bits of code, and also gives us a way to break complex ideas down into parts. 
</p>


<h4>Names, grouped</h4>

<p>
My language puts names into groups based on how they are defined. An example of this is the set of consecutive name definitions in a file such as what we have seen above form a group. The rules of my language are that within these groups, once a name is created its value cannot change, and no other value can be created with the same name. 
</p>

<p>
In my language there are a few ways to make groups of names. This is often a good strategy for organising code. One way to form a name group is to denote components of a compound value, as in the following example.
</p>

<pre>
myOperatingSystem = ( .os = "Windows", .version = 10 );

versionIsModern = myOperatingSystem.version > 7
</pre>

<p>
So what's going on here? The first line is relating the name <code>myOperatingSystem</code> with a definition with multiple parts. Let's break up the parts of the syntax: an open bracket <code>(</code>, an initial period <code>.</code>, a definition for <code>os</code>, a comma <code>,</code>, another period and definition for <code>version</code>, and a closing bracket <code>)</code>. The names defined between the brackets form a group, distinct from the group of names that we have seen so far. We will say that these names introduced in a bracket group are the names of components of the compound value. 
</p>

<p>
In the last line, we create a name <code>versionIsModern</code> with a definition that begins with our previously defined named value <code>myOperatingSystem</code> followed by a period and <code>version</code>, which is the name of one of the components of <code>myOperatingSystem</code>. This syntax of following a compound value by a period and component name is a way in which we can refer to the component value. The rest of the definition uses the greater-than symbol <code>></code> to compare the <code>version</code> component to <code>7</code>. 
</p>

<p>
With the bracket syntax it is possible to use names from the outer group in definitions for the components of the group as shown in the following code. Here, <code>myOldVersion</code> is used to define the <code>version</code> component of <code>myUpgradedOperatingSystem</code>.
</p>

<pre>
myOldVersion = 7;

myUpgradedOperatingSystem = ( .os = "Windows", .version = myOldVersion + 1 );
</pre>

<h4>Names, grouped again</h4>

<p>
There is one more syntactical construction in my language for grouping of names that is resembles more how we have defined names so far. Let's look at some more code.
</p>

<pre>
myPoint = {
  .x = 4;
  .y = x + 2;
};

myPointHeight = myPoint.y; 
</pre>

<p>
Let's get into what's happening here. In the first few lines we define <code>myPoint</code> to be a compound value that looks a bit like the bracket syntax used to declare <code>myOperatingSystem</code> earlier. Let's contrast the new syntax for the value definition, starting from the last character of the first line, where we have an open brace <code>{</code> instead of a bracket. The next line begins with an indent of 2 spaces. We recall that spaces (including line breaks) can be skipped over when reading my language code. The rest of the line has the familiar definition syntax, and we see a return to using semi-colons to end definitions, instead of the comma used in the bracket form. Like with the bracket syntax, and unlike the other definitions we have made, the left hand side name is prefixed by a period. The next line has a similar form, and makes use of <code>x</code> to define the name <code>y</code>. Notably, we do not need the period prefix when using <code>x</code>, and can in fact treat it as if it was defined without. This is a key difference between the forms - when using this brace form syntax, my language allows definitions to refer to names from the same group. The next line ends the compound value with a closing brace <code>}</code>, instead of the closing bracket of the other form. Finally the definition of <code>myPoint</code> terminates with a semi-colon.
</p>

<p>
Skipping the blank line, the next part of the code defines <code>myPointHeight</code> using the previously defined name <code>myPoint</code>, referring to its <code>.y</code> component in a similar manner to how <code>versionIsModern</code> was defined earlier in terms of <code>myOperatingSystem.version</code>. This ability to access components of compound values through the value name is conferred by the period prefix on the component name.
</p>

<p>
Effectively, a set of names defined consecutively between braces form a group where the prefixed names of the group indicate the accessible components of the value.
</p>

<p>
We can introduce names to the group that are not prefixed. These names can be used for defining other names in the group, but do not become named components of the value. We could have equivalently written a definition for <code>myPoint</code> as below.
</p>

<pre>
myEquivalentPoint = {
  intercept = 2;
  .x = 4;
  .y = x + intercept;
};
</pre>

<p>
Without a period prefix when creating the name <code>intercept</code>, my language does not allow access to <code>myEquivalentPoint.intercept</code>. 
The named components are <code>.x</code> and <code>.y</code>.
</p>


<p>
If we consider the definitions of <code>myPoint</code>, we would expect that the <code>.y</code> component assigned to <code>myPointHeight</code> will evaluate to <code>6</code>.
</p>

<h4>Names, updated</h4>

<p>
The following code demonstrates a fundamental feature of my language. Let's look at it first and then talk through what it does.
</p>

<pre>
myPoint2 = myPoint{ .x = 5 };

myPoint2Height = myPoint2.y;
</pre>

<p>
In the first of these lines, we create the name <code>myPoint2</code> and define the value using yet another new syntactic form: the use of a name <code>myPoint</code> defined earlier followed by some syntax that looks similar to the earlier definition for <code>myPoint</code>, namely some braces surrounding a definition of the name <code>x</code>. This form is used to defined values that extend other values with new components, and with updates to already existing components. In this case, the update defines a <code>.x</code> component, which <code>myPoint</code> has. We can understand the new value for <code>myPoint2</code> as being defined as a revised version of <code>myPoint</code>, with the <code>x</code> name defined to be <code>5</code> instead of <code>4</code>.
</p>

<p>
The last definition for <code>myPoint2Height</code> thus refers to the <code>.y</code> component of <code>myPoint2</code>, calculated using the updated <code>.x</code> component, and should evaluate to <code>7</code>.
</p>

<p>
This ability to create new extended and updated versions of values as exhibited by <code>myPoint2</code>'s definition is what allows us to do computations. 
</p>

<p>
There are actually only a couple more syntactical forms to my language, which we will look at briefly, then we can get try it out with some examples. Another small piece of code demonstrates one of these forms.
</p>

<pre>
myPlane = { .z = .x - .y + 7 };

myPointDepth = myPlane( .x = 1, .y = 2 ).z;
</pre>

<p>
Looking at the first line, which defines the name <code>myPlane</code> as a compound value with an accessible named component <code>z</code>, where <code>z</code> uses two period prefixed names <code>x</code> and <code>y</code> which have no corresponding definition in the group. Including the prefix in the use site indicates that we expect values for these names to be provided in an updated version of the value. Note that directly accessing the <code>.z</code> component of <code>myPlane</code> will cause an error! My language will often feature values with these partially defined components, which act as templates from which complete values can be made using the value update syntax. 
</p>

<p>
With the next code part we have an example of using <code>myPlane</code>. This time we have used the earlier form of compound value definition with brackets to apply our updated values, but it works in the same way as the braces form, with the defined values for the <code>.x</code> and <code>.y</code> components being substituted in the definition for <code>myPlane</code>. In this case we don't bother to name the updated value we have created, and immediately extract the <code>.z</code> component to assign as the definition for <code>myPointDepth</code>.
</p>


