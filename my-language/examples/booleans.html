<h2>My language example - Booleans</h2>

<h4>True and False</h4>

<p>
Here is some code implementing the two boolean values, <code>True</code> and <code>False</code>: 
</p>

<pre>
True = {
  .match = .ifTrue;
};

False = {
  .match = .ifFalse;
};
</pre>

<p>
The two declarations use the brace form for declaring compound values, which we call 'block' syntax. Both <code>True</code> and <code>False</code> have components <code>.match</code> that reference other component names (<code>.ifTrue</code> and <code>.ifFalse</code> respectively) that are not defined in the block, which indicates that these are intended as prototype values, requiring the missing component to be filled in before accessing <code>.match</code>. We can call these undefined components 'implicit' components. 
</p>

</p>
It might not be immediately obvious how these two values encode the usual true and false values. The intuition is that if we are dealing with a unknown boolean value in our code, we would extend it to specify what to do for the two possible branches <code>.ifTrue</code> and <code>.ifFalse</code>, then accessing <code>.match</code> will cause the corresponding branch to be entered (note that <code>False</code> will enter <code>.ifFalse</code> and <code>True</code> will enter <code>.ifTrue</code>). A use of these values is demonstrated in the following example describing the boolean <em>and</em> operation. 
</p>

<pre>
and = {
  .call = .arg1 ( .ifTrue = .arg2, .ifFalse = False ).match;
};
</pre>

<p>
We see that <code>and</code> is being defined using block syntax, with a component <code>.call</code> that is defined using juxtaposition to update an implicit component <code>.arg1</code> and the bracket form for declaring compound values, which we can call 'tuple' syntax. The power of this form is no nested scope is generated, so names in component definitions scope to outside of the tuple. This means that the reference to <code>.arg1</code> in the definition for <code>.ifTrue</code> refers to an implicit component of the value for <code>and</code>.

<p>
The definition of <code>and</code> has three names: <code>arg1</code>, <code>arg2</code> and <code>call</code> which is public, and introduces some new syntax: In the <code>arg1</code> value, we see a reference directly followed by an extended definition <code>{}</code>. This expresses extending the first value with the fields declared in the second. The field access syntax <code>[value].[field]</code>, when used on the right hand side of declarations forms a reference to a field of the value. An example of this is the <code>call</code> field definition.
</p>

<p>
The 'scoping' rules define which value (if any) a name refers to. The rules differ for plain references (not preceded by a <code>.</code>) and field references (preceded by <code>.</code>). Plain references point to a value with that name within the same definition <code>{}</code> as the reference, if one exists, otherwise for nested definitions, the value is found as if the reference were made in the enclosing definition.
<p>

</p>
These rules have some interesting implications which we will see later. For now, we will apply the scoping rules for the references in the definition of <code>and</code> above. In one case, the value of the  field reference <code>arg1</code> is updated with new fields <code>ifTrue</code> and <code>ifFalse</code>. We will come to field reference scoping in a moment. The new <code>ifTrue</code> and <code>ifFalse</code> values are a reference to <code>arg2</code> and <code>False</code> respectively. By the rules above, we would first look for a declarations with these names in the same definition. Here only <code>ifTrue</code> and <code>ifFalse</code> names exist, so we continue looking in the enclosing definition. The enclosing definition declares names <code>arg2</code>, <code>arg1</code> and <code>call</code>, and we have therefore found the value referenced by the <code>arg2</code> reference, itself a field reference to <code>arg2</code>. For the <code>False</code> value, we have to look further into the top-level set of declarations, where it was defined above.
</p>

<p>
In another case, the field <code>call</code> references to <code>arg1</code> from which the field <code>match</code> is accessed. The name <code>arg1</code> exists in the same definition, so the reference resolves to the corresponding value. 
</p>

<p>
Field references work in combination with definition extension as seen in the <code>arg1</code> value declared in <code>and</code>. They are resolved by need, when computing a value to return via a field access, and refer to the latest value defined for the corresponding field. We can begin to understand why in our definitions for <code>True</code> and <code>False</code> it is permitted to make field references to the non-existent fields <code>ifTrue</code> and <code>ifFalse</code>. As long as the fields are supplied by definition extension before accessing the <code>match</code> field, everything will be fine.
</p>

<h4>Meaning of my code</h4>

<p>
The execution of my language occurs in a predictable fashion, allowing code behaviour to be reasoned about with a bit of practice. We illuminate this by working through the following example: Verifying that a particular case of our definition for <code>and</code> is consistent with that of boolean logical, demonstrated by following truth-table:
</p>

<pre>
<table>
  <tbody>
    <tr><td>and</td><td>arg1=True</td><td>arg1=False</td></tr>
    <tr><td>arg2=True</td><td>call=True</td><td>call=False</td></tr>
    <tr><td>arg2=False</td><td>call=False</td><td>call=False</td></tr>
  </tbody>
</table>
</pre>

<p>
The case represented by the top left cell can be expressed by the following my code:
</p>

<pre>
expectTrue = and { .arg1 = True; .arg2 = True; }.call;
</pre>

<p>
The code above expresses substituting the value <code>True</code> for fields <code>arg1</code> and <code>arg2</code> in <code>and</code>, and the corresponding updated value for the <code>call</code> field is being assigned as <code>expectTrue</code>.
</p>

<p>
How is the value assigned to <code>expectTrue</code> arrived at? In my language, field accesses drive computation. <code>expectTrue</code> will have the value of the <code>call</code> field of the updated <code>and</code> value. My language exhibits the property that a reference can always be substituted with the definition of the referenced value, without changing the computation result - a property often called 'referential transparency'. The property implies that to work out the value of the <code>call</code> field, we can replace <code>and</code> by its definition and add the new <code>arg1</code> and <code>arg2</code> fields, and the substituted value is equivalent to the original. We represent the substituted value below. Syntactically, my language forbids duplicate names in a definition, which would make references to <code>arg1</code> and <code>arg2</code> ambiguous. We avoid this in the represented value by relabelling both the declarations and references to <code>arg1</code> and <code>arg2</code> to preserve which values are referenced - a process known as alpha-renaming. 
</p>

<pre>
expectTrue = {
  .arg1 = True;
  
  .arg2 = True;
  
  arg2x = .arg2;
  
  arg1x = .arg1 {
    .ifTrue = arg2x;
    
    .ifFalse = False;
  };
  
  .call = arg1x.match;
}.call;
</pre>

<p>
After these substitutions, we can see that a <code>call</code> field exists in the expanded definition of <code>and</code>, which we want to extract as the value of <code>expectTrue</code>. Doing this directly, however, will lead to a problem - the definition of <code>call</code> has a reference to another value in the same definition <code>arg1x</code>. We would to lose the linked value if we simply extracted <code>call</code>'s definition, and now <code>arg1x</code> would reference a different value (or no value). My language obeys another principle, that references are resolved and fixed to found values during a field access. This principle is called 'lexical closure'. We can satisfy this principle by substituting <code>arg1x</code> for its definition, and other locally defined names as necessary until <code>call</code> has no local references. 
</p>

<pre>
expectTrue = {
  .arg1 = True;
  
  .arg2 = True;
  
  .call = True {
    .ifTrue = True;
    
    .ifFalse = False;
  }.match;
}.call;
</pre>


<p>
After this rewrite, the definition of <code>call</code> is independent of the other fields in the definition, and we can extract the value to assign to <code>expectTrue</code>.
</p>

<pre>
expectTrue = True {
  .ifTrue = True;
  
  .ifFalse = False;
}.match;
</pre>

<p>
Our value involves another field access, meaning we can compute further, substituting the definition of <code>True</code> and extracting the <code>match</code> field. Including the definition above gives:
</p>

<pre>
expectTrue = {
  .ifTrue = True;
  
  .ifFalse = False;
  
  .match = .ifTrue;
}.match;
</pre>

<p>
We are nearly there. To avoid losing the field reference to <code>ifTrue</code>, we substitute its value <code>True</code> and finally extract <code>match</code>:
</p>

<pre>
expectTrue = True;
</pre>

<p>
QED. We have thus verified the top corner of the truth-table for boolean and. The enthusiastic reader can verify the other three cases as an exercise.
</p>