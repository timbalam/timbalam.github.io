<h2>Blog</h2>

<a href="../index.html">Home</a>

<h4>I have made a programming language</h4>

<a href="#try-it-out">Try it out</a>

<p>
I have made a programming language. The working name for the language is "my". My language is designed around a flexible universal structure
</p>

<h4>Using my language</h4>

<p>
We use a text editor to write our program code, and then give the text file to the <code>myi</code> program to execute. <code>myi</code> is short for "My interpreter" because it interprets the code you wrote based on the rules of my language. <code>myi</code> is run from the command line or terminal of your computer. To install <code>myi</code> see <a href="#try-it-out">here</a>.
</p>

<h4>My code examples</h4>

<p>
Let's start by working through an example - implementations of the two boolean values, <code>True</code> and <code>False</code>: 
</p>

<pre>
True = {
  .ifTrue =;
  
  .ifFalse =;
  
  .match = ifTrue;
};

False = {
  .ifTrue =;
  
  .ifFalse =;
  
  .match = ifFalse;
};
</pre>

<p>
Here we have declared definitions for two values <code>True</code> and <code>False</code>. The definitions use the syntax <code>[name]=[value]</code> to declare a set of fields and values, separated by semi-colons <code>;</code> and surrounded by curly braces <code>{}</code>. Both values have three fields: <code>ifTrue</code>, <code>ifFalse</code>, and <code>match</code>. Note that the fields <code>ifTrue</code> and <code>ifFalse</code> are not assigned values - we will see what this means a little later. The values are differentiated by the third field <code>match</code>, which refers respectively to the <code>ifTrue</code> field for the <code>True</code> value and the <code>ifFalse</code>  field for the <code>False</code> value. 
</p>

<p>
Using names of fields defined elsewhere in the program, as is seen in the <code>match</code> field definitions, is called 'referencing', and introduces a dependency between the definitions. Which fields can be referenced when writing definitions is determined by my language's 'scoping rules'. Fields which can be referenced in a particular definition are said to be 'in scope' for that definition.
</p>

<p>
The scoping rules of my language can be stated simply: fields declared within a definition <code>{}</code> are in scope for that definition. Additionally, any fields in the 'enclosing scope', the scope of the enclosing definition of a nested definition, are also in scope for the nested definition. We will discuss some interesting implications of these rules in more details later.
</p>

<p>
Each of the fields of <code>True</code> and <code>False</code> are declared beginning with a period <code>.</code>, indicating that they are public fields, able to be read and manipulated by code outside of the value's definition, where they are not in scope. Let's demonstrate this by defining the boolean "and" operation. 
</p>

<pre>
and = {
  .bool1 =;
  
  .bool2 =;
  
  .call = {
    .ifTrue =;
    
    .ifFalse =;
    
    bool2.ifTrue = ifTrue;
    
    bool2.ifFalse = ifFalse;
    
    bool1.ifTrue = bool2.match;
    
    bool1.ifFalse = ifFalse;
    
    .match = bool1.match;
  };
};
</pre>

<p>
The definition of <code>and</code> has three public fields: <code>boo11</code>, <code>bool2</code> and <code>call</code>. The definition for <code>call</code> references the other fields <code>bool1</code> and <code>bool2</code> in two ways:
</p>

<p>
The syntax <code>[name].[field]</code> on the left hand side of the equals sign <code>=</code>, for a name defined in the enclosing scope, forms a modified value within the definition with a new value assigned to the field.
</p>

<p>
The same syntax <code>[value].[field]</code> on the right hand side of declarations forms a reference to a public field of the value. 
</p>

<p>
Hence, the definition of <code>call</code> above states that the fields <code>ifTrue</code> and <code>ifFalse</code> of <code>bool2</code> and the <code>ifFalse</code> field of <code>bool1</code> are updated to redirect to the corresponding fields of the <code>call</code> value, the <code>ifTrue</code> field of <code>bool1</code> is updated to redirect to the <code>match</code> field of the updated <code>bool2</code>, and the <code>match</code> field of the <code>call</code> value linked to the <code>match</code> of <code>bool1</code>.
</p>


<h4>Meaning of my code</h4>

<p>
To verify that our definition for <code>and</code> is consistent with that of boolean logical, we would want the following truth-table to hold:
</p>

<pre>
<table>
  <tbody>
    <tr><td>and</td><td>bool1=True</td><td>bool1=False</td></tr>
    <tr><td>bool2=True</td><td>call=True</td><td>call=False</td></tr>
    <tr><td>bool2=False</td><td>call=False</td><td>call=False</td></tr>
  </tbody>
</table>
</pre>

<p>
The case represented by the top left cell can be expressed by the following my code, featuring some new syntax:
</p>

<pre>
expectTrue = and { .bool1 = True; .bool2 = True; }.call
</pre>

<p>
The juxtaposition syntax <code>[value] [value]</code> binds tighter than the field access, and is an alternative way to express updating multiple field values of the first value with the corresponding field values of the second. In this case, the value <code>True</code> is being substituted as the values for fields <code>bool1</code> and <code>bool2</code> in <code>and</code>, and the corresponding updated value for the <code>call</code> field is being assigned as <code>expectTrue</code>.
</p>

<p>
What exactly is meant above by 'substitute' and 'update'? How is the value assigned to <code>expectTrue</code> arrived at? In my language, computation is driven by field accesses. <code>expectTrue</code> will have the value of the <code>call</code> field of the updated <code>and</code> value. Working this out requires finding and replacing <code>and</code> by its definition, and further replacing the <code>bool1</code> and <code>bool2</code> fields with their new value <code>True</code>:
</p>

<pre>
expectTrue = {
  .bool1 = True;
  
  .bool2 = True;
  
  .call = {
    .ifTrue =;
    
    .ifFalse =;
    
    bool2.ifTrue = ifTrue;
    
    bool2.ifFalse = ifFalse;
    
    bool1.ifTrue = bool2.match;
    
    bool1.ifFalse = ifFalse;
  
    .match = bool1.match;
  };
}.call;
</pre>

<p>
After these substitutions, we can see that a <code>call</code> field exists in the expanded definition of <code>and</code>, which we want to extract as the value of <code>expectTrue</code>. Doing this directly, however, will lead to a problem - the definition of <code>call</code> depends on <code>bool1</code> and <code>bool2</code>, which are defined externally. We introduce some new syntax and perform a small rewriting of <code>call</code>'s definition which moves these 'captured' references inside. 
</p>

<pre>
expectTrue = {
  .bool1 = True;
  
  .bool2 = True;
  
  .call = {
    .ifTrue =;
    
    .ifFalse =;
    
    bool2 = True { ifTrue, ifFalse }
    
    bool1 = True { .ifTrue = bool2.match, ifFalse }
  
    .match = bool1.match;
  };
}.call;
</pre>

<p>
The syntax of using a bare <code>[name]</code> inside a definition, creates a 'punned' definition, simply assigning the value corresponding to the name in the enclosing scope to a public field of the same name within the definition.
</p>

<p>
This is combined with the juxtaposition syntax above to update the captured <code>True</code> values for <code>bool1</code> and <code>bool2</code>, redirecting fields <code>ifTrue</code> and <code>ifFalse</code> to the values for the corresponding fields of <code>call</code>. After the rewrite, the definition of <code>call</code> is independent of the other fields of the expanded <code>and</code> code, and we can extract the value to assign to <code>expectTrue</code>.
</p>

<pre>
expectTrue = {
  .ifTrue =;
  
  .ifFalse =;
  
  bool2 = True { ifTrue, ifFalse }
  
  bool1 = True { .ifTrue = bool2.match, ifFalse }

  .match = bool1.match;
};
</pre>

<p>
Does the value of <code>expectTrue</code> correspond to that of <code>True</code>? Remember that the <code>match</code> field of <code>True</code> redirects to that of the <code>ifTrue</code> field. This implies that same holds for <code>expectTrue</code> - <code>bool1.match</code> redirects to the substituted value <code>bool2.match</code>, which redirects to the punned <code>ifTrue</code> field of <code>expectTrue</code>.
</p>


<h4>Where are my primitives? My IO?</h4>

<p>
Oh boy
</p>
